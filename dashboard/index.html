<!DOCTYPE html>
<!--
  ============================================================================
  SEISMIC RISK MONITORING DASHBOARD
  ============================================================================
  Real-time seismic monitoring dashboard using CatBoost models
  Adapted from: https://github.com/kiflomhailu/project_datascience_secondYear
  Models: Event Occurrence, Magnitude Prediction, Traffic Light (3-class)
  ============================================================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Seismic Risk Dashboard - CatBoost Models</title>

  <!-- React 18 via CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Chart.js 4.4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <!-- Chart.js Zoom Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- Date Adapter for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow-x: hidden;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      color: #1a202c;
      min-height: 100vh;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      25% { transform: translateY(-20px) rotate(5deg); }
      50% { transform: translateY(-10px) rotate(-5deg); }
      75% { transform: translateY(-15px) rotate(3deg); }
    }

    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: float 20s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }

    #root {
      min-height: 100vh;
      padding: 20px;
      position: relative;
      z-index: 1;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 30px;
      padding: 25px 30px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1), 0 2px 8px rgba(102, 126, 234, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .logo {
      font-size: 32px;
      font-weight: 900;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -1px;
      animation: shimmer 4s linear infinite;
      text-shadow: 0 2px 20px rgba(102, 126, 234, 0.3);
    }

    @keyframes shimmer {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .subtitle {
      color: #64748b;
      font-size: 14px;
      font-weight: 600;
      margin-top: 6px;
      letter-spacing: 0.3px;
    }

    /* Navigation Tabs */
    .nav-tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 25px;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 8px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1), 0 2px 8px rgba(102, 126, 234, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .nav-tab {
      padding: 14px 28px;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 12px;
      font-weight: 600;
      font-size: 15px;
      color: #64748b;
      transition: all 0.3s;
    }

    .nav-tab:hover {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
    }

    .nav-tab.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5), 0 0 30px rgba(118, 75, 162, 0.3);
      transform: translateY(-2px) scale(1.05);
    }

    /* KPI Cards */
    .kpis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .kpi-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08), 0 2px 10px rgba(102, 126, 234, 0.12);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }

    .kpi-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 20px;
      padding: 2px;
      background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      opacity: 0;
      transition: opacity 0.4s;
    }

    .kpi-card:hover {
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 20px 60px rgba(102, 126, 234, 0.25), 0 4px 20px rgba(118, 75, 162, 0.2), 0 0 0 1px rgba(102, 126, 234, 0.3);
      border-color: rgba(102, 126, 234, 0.3);
    }

    .kpi-card:hover::before {
      opacity: 1;
    }

    .kpi-card h4 {
      font-size: 12px;
      font-weight: 700;
      color: #64748b;
      margin: 0 0 12px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .kpi-value {
      font-size: 42px;
      font-weight: 900;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      background-size: 200% auto;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0;
      line-height: 1.1;
      letter-spacing: -1px;
      transition: all 0.5s;
      animation: shimmer 3s linear infinite;
    }

    .kpi-card:hover .kpi-value {
      transform: scale(1.08);
      animation-duration: 1s;
    }

    /* Chart Container */
    .chart-container {
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      border-radius: 24px;
      padding: 35px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08), 0 2px 10px rgba(102, 126, 234, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
      margin-bottom: 25px;
      min-height: 500px;
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.6);
      transition: all 0.3s ease;
    }

    .chart-container:hover {
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.12), 0 4px 15px rgba(102, 126, 234, 0.15), inset 0 1px 0 rgba(255, 255, 255, 1);
    }

    .chart-container h3 {
      font-size: 18px;
      font-weight: 700;
      margin: 0 0 25px 0;
      color: #1e293b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .chart-wrapper {
      position: relative;
      height: 450px;
      width: 100%;
    }

    /* Controls */
    .controls {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(30px);
      -webkit-backdrop-filter: blur(30px);
      padding: 30px;
      border-radius: 20px;
      margin-bottom: 25px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08), 0 2px 10px rgba(102, 126, 234, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .control-item label {
      display: block;
      font-size: 12px;
      font-weight: 700;
      color: #475569;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-item input, .control-item select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-size: 14px;
      transition: all 0.3s;
      background: white;
    }

    .control-item input:focus, .control-item select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.15), 0 4px 20px rgba(102, 126, 234, 0.25), 0 8px 40px rgba(118, 75, 162, 0.15);
      background: #ffffff;
      transform: translateY(-2px);
    }

    /* Metrics Grid */
    .metrics-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
      align-items: center;
    }

    .metric-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 15px;
      border-radius: 8px;
      transition: all 0.2s ease;
      border: 2px solid #e2e8f0;
      background: white;
      cursor: pointer;
    }

    .metric-checkbox:hover {
      background: #f8fafc;
      border-color: #cbd5e1;
    }

    .metric-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #667eea;
      transition: all 0.2s ease;
    }

    .metric-checkbox input[type="checkbox"]:checked {
      accent-color: #667eea;
    }

    .metric-checkbox label {
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      margin: 0;
      color: #1e293b;
      white-space: nowrap;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 60px 20px;
      font-size: 18px;
      color: #64748b;
    }

    .loading-spinner {
      display: inline-block;
      width: 80px;
      height: 80px;
      position: relative;
      margin-bottom: 30px;
    }

    .loading-spinner::before,
    .loading-spinner::after {
      content: '';
      position: absolute;
      border-radius: 50%;
      border: 6px solid transparent;
      animation: spin 1.5s cubic-bezier(0.5, 0, 0.5, 1) infinite;
    }

    .loading-spinner::before {
      width: 80px;
      height: 80px;
      border-top-color: #667eea;
      border-right-color: #764ba2;
      border-bottom-color: #f093fb;
      animation-duration: 1.5s;
    }

    .loading-spinner::after {
      width: 60px;
      height: 60px;
      top: 10px;
      left: 10px;
      border-top-color: #4facfe;
      border-right-color: #00f2fe;
      animation-direction: reverse;
      animation-duration: 2s;
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Error */
    .error {
      background: #fee;
      border: 2px solid #fcc;
      color: #c00;
      padding: 20px;
      border-radius: 12px;
      margin: 20px 0;
    }

    /* Button */
    button {
      padding: 14px 28px;
      border: none;
      border-radius: 14px;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      font-size: 12px;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    button:hover::before {
      width: 400px;
      height: 400px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.5), 0 4px 12px rgba(118, 75, 162, 0.3), 0 0 40px rgba(102, 126, 234, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-primary:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 15px 50px rgba(102, 126, 234, 0.6), 0 8px 20px rgba(118, 75, 162, 0.4), 0 0 60px rgba(102, 126, 234, 0.5);
    }

    /* Responsive */
    @media (max-width: 768px) {
      body { padding: 10px; }
      .kpis { grid-template-columns: 1fr; }
      .chart-container { padding: 20px; min-height: 300px; }
    }

    /* Traffic Light Badge */
    .traffic-badge {
      display: inline-block;
      padding: 6px 16px;
      border-radius: 20px;
      font-weight: 700;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .traffic-green {
      background: #10b981;
      color: white;
    }

    .traffic-yellow {
      background: #f59e0b;
      color: white;
    }

    .traffic-red {
      background: #ef4444;
      color: white;
    }

    /* Chart Toolbar */
    .chart-toolbar {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-bottom: 10px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 8px;
    }

    .chart-toolbar button {
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 36px;
      height: 36px;
    }

    .chart-toolbar button:hover {
      background: #e5e7eb;
      border-color: #9ca3af;
    }

    .chart-toolbar button:active {
      transform: scale(0.95);
    }

    .chart-toolbar button.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }

    /* Event Table */
    .event-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }

    .event-table th {
      background: #f8f9fa;
      padding: 12px;
      text-align: left;
      font-weight: 600;
      font-size: 13px;
      color: #475569;
      border-bottom: 2px solid #e2e8f0;
    }

    .event-table td {
      padding: 10px 12px;
      border-bottom: 1px solid #e2e8f0;
      font-size: 14px;
    }

    .event-table tbody tr:hover {
      background: rgba(102, 126, 234, 0.05);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // API Configuration
    const API_BASE_URL = 'https://seismic-dashboard-latest.onrender.com';

    // Operational Variables
    const OPERATIONAL_VARS = {
      'inj_flow': 'Total Injection Flow Rate (m¬≥/h)',
      'basin_flow': 'Basin Injection Flow Rate (m¬≥/h)',
      'gt03_whp': 'GT03 Wellhead Pressure (bar)',
      'inj_whp': 'Injection Wellhead Pressure (bar)',
      'inj_ap': 'Injection Annular Pressure (bar)',
      'inj_temp': 'Injection Wellhead Temperature (¬∞C)',
      'prod_whp': 'Production Wellhead Pressure (bar)',
      'prod_temp': 'Production Wellhead Temperature (¬∞C)',
      'prod_flow': 'Production Flow (m¬≥/h)',
      'inj_energy': 'Injected Energy (MWh)',
      'cooling_energy': 'Extracted Energy (MWh)',
      'hedh_thpwr': 'Heat Exchanger Thermal Power (kW)',
      'heat_exch_energy': 'Heat Exchanger Energy (MWh)',
      'volume': 'Injected Volume (m¬≥)',
      'cum_volume': 'Cumulative Volume (m¬≥)',
      'cum_inj_energy': 'Cumulative Injected Energy (MWh)',
      'cum_cooling_energy': 'Cumulative Cooling Energy (MWh)',
    };

    // Traffic Light Mapping
    const TRAFFIC_CONFIG = {
      0: { label: 'GREEN', color: '#10b981', icon: 'üü¢' },
      1: { label: 'YELLOW', color: '#f59e0b', icon: 'üü°' },
      2: { label: 'RED', color: '#ef4444', icon: 'üî¥' }
    };

    // Chart Colors - Ultra vibrant palette
    const CHART_COLORS = [
      '#667eea', // Primary Purple
      '#00f2fe', // Cyan Bright
      '#f093fb', // Pink Bright
      '#4facfe', // Blue Bright
      '#43e97b', // Green Bright
      '#fa709a', // Rose Bright
      '#fee140', // Yellow Bright
      '#30cfd0', // Teal Bright
      '#a8edea', // Mint
      '#ff6a88', // Coral
      '#c471ed', // Purple Light
      '#38f9d7'  // Turquoise
    ];

    // =================================================================
    // API CLIENT
    // =================================================================

    async function fetchAPI(endpoint, options = {}) {
      try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'API request failed');
        }
        return await response.json();
      } catch (error) {
        console.error(`API Error (${endpoint}):`, error);
        throw error;
      }
    }

    // =================================================================
    // MAIN APP
    // =================================================================

    function App() {
      const [activeTab, setActiveTab] = useState('operational');
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);
      const [dataInfo, setDataInfo] = useState(null);
      const [healthStatus, setHealthStatus] = useState(null);

      useEffect(() => {
        loadInitialData();
      }, []);

      async function loadInitialData() {
        try {
          setLoading(true);
          setError(null);
          
          // Check health
          const health = await fetchAPI('/health');
          setHealthStatus(health);
          
          if (health.status !== 'ok') {
            throw new Error('API is not ready');
          }

          // Get data info
          const info = await fetchAPI('/data/info');
          setDataInfo(info);
          
          setLoading(false);
        } catch (err) {
          setError(err.message);
          setLoading(false);
        }
      }

      if (loading) {
        return (
          <div className="container">
            <div className="loading">
              <div className="loading-spinner"></div>
              <div>Loading dashboard...</div>
            </div>
          </div>
        );
      }

      if (error) {
        return (
          <div className="container">
            <div className="error">
              <h2>‚ö†Ô∏è Error Loading Dashboard</h2>
              <p>{error}</p>
              <button className="btn-primary" onClick={loadInitialData}>
                Retry
              </button>
            </div>
          </div>
        );
      }

      return (
        <div className="container">
          <header>
            <div>
              <div className="logo">üö® Seismic Risk Monitor</div>
              <div className="subtitle">
                CatBoost Models ‚Ä¢ Real-time Prediction ‚Ä¢ Traffic Light System
              </div>
            </div>
            <div>
              <span style={{fontSize: '12px', color: '#64748b'}}>
                {dataInfo?.total_records?.toLocaleString()} records loaded
              </span>
            </div>
          </header>

          <div className="nav-tabs">
            <button
              className={`nav-tab ${activeTab === 'operational' ? 'active' : ''}`}
              onClick={() => setActiveTab('operational')}
            >
              üìä Operational Dashboard
            </button>
            <button
              className={`nav-tab ${activeTab === 'risk' ? 'active' : ''}`}
              onClick={() => setActiveTab('risk')}
            >
              üö® Risk Dashboard
            </button>
          </div>

          {activeTab === 'operational' && <OperationalDashboard dataInfo={dataInfo} />}
          {activeTab === 'risk' && <RiskDashboard dataInfo={dataInfo} />}
        </div>
      );
    }

    // =================================================================
    // OPERATIONAL DASHBOARD
    // =================================================================

    function OperationalDashboard({ dataInfo }) {
      const [data, setData] = useState([]);
      const [loading, setLoading] = useState(false);
      const [selectedVars, setSelectedVars] = useState(['inj_whp', 'prod_whp', 'inj_temp', 'prod_temp']);
      const [showSeismicity, setShowSeismicity] = useState(true);
      const [showPhases, setShowPhases] = useState(false);
      const [showPits, setShowPits] = useState(false);
      const [dateRange, setDateRange] = useState({
        start: dataInfo?.min_date?.split('T')[0] || '',
        end: dataInfo?.max_date?.split('T')[0] || ''
      });

      useEffect(() => {
        loadData();
      }, [dateRange, selectedVars]);

      async function loadData() {
        try {
          setLoading(true);
          const variables = selectedVars.join(',');
          const result = await fetchAPI(
            `/data/operational?start_date=${dateRange.start}&end_date=${dateRange.end}&variables=${variables}`
          );
          setData(result.data || []);
          setLoading(false);
        } catch (err) {
          console.error('Error loading data:', err);
          setLoading(false);
        }
      }

      function toggleVariable(varKey) {
        setSelectedVars(prev => 
          prev.includes(varKey) 
            ? prev.filter(v => v !== varKey)
            : [...prev, varKey]
        );
      }

      return (
        <div>
          {/* Controls */}
          <div className="controls">
            <div className="controls-grid">
              <div className="control-item">
                <label>Start Date</label>
                <input
                  type="date"
                  value={dateRange.start}
                  onChange={(e) => setDateRange({...dateRange, start: e.target.value})}
                />
              </div>
              <div className="control-item">
                <label>End Date</label>
                <input
                  type="date"
                  value={dateRange.end}
                  onChange={(e) => setDateRange({...dateRange, end: e.target.value})}
                />
              </div>
            </div>

            <div className="metrics-grid">
              {Object.entries(OPERATIONAL_VARS).map(([key, label]) => (
                <div key={key} className="metric-checkbox">
                  <input
                    type="checkbox"
                    id={`var-${key}`}
                    checked={selectedVars.includes(key)}
                    onChange={() => toggleVariable(key)}
                  />
                  <label htmlFor={`var-${key}`}>{label}</label>
                </div>
              ))}
            </div>

            {/* Additional Controls */}
            <div style={{marginTop: '20px', display: 'flex', gap: '15px', flexWrap: 'wrap'}}>
              <button
                onClick={() => setShowSeismicity(!showSeismicity)}
                style={{
                  padding: '10px 20px',
                  backgroundColor: showSeismicity ? '#667eea' : 'white',
                  color: showSeismicity ? 'white' : '#64748b',
                  border: `2px solid ${showSeismicity ? '#667eea' : '#e2e8f0'}`,
                  borderRadius: '10px',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: '600',
                  transition: 'all 0.3s ease',
                  boxShadow: showSeismicity ? '0 4px 12px rgba(102, 126, 234, 0.3)' : 'none'
                }}
              >
                {showSeismicity ? '‚úì ' : ''}Show Seismicity
              </button>
              <button
                onClick={() => setShowPhases(!showPhases)}
                style={{
                  padding: '10px 20px',
                  backgroundColor: showPhases ? '#667eea' : 'white',
                  color: showPhases ? 'white' : '#64748b',
                  border: `2px solid ${showPhases ? '#667eea' : '#e2e8f0'}`,
                  borderRadius: '10px',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: '600',
                  transition: 'all 0.3s ease',
                  boxShadow: showPhases ? '0 4px 12px rgba(102, 126, 234, 0.3)' : 'none'
                }}
              >
                {showPhases ? '‚úì ' : ''}Show Phases
              </button>
              <button
                onClick={() => setShowPits(!showPits)}
                style={{
                  padding: '10px 20px',
                  backgroundColor: showPits ? '#667eea' : 'white',
                  color: showPits ? 'white' : '#64748b',
                  border: `2px solid ${showPits ? '#667eea' : '#e2e8f0'}`,
                  borderRadius: '10px',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: '600',
                  transition: 'all 0.3s ease',
                  boxShadow: showPits ? '0 4px 12px rgba(102, 126, 234, 0.3)' : 'none'
                }}
              >
                {showPits ? '‚úì ' : ''}Show Pits
              </button>
            </div>
          </div>

          {/* Chart with Events Overlay */}
          <div className="chart-container">
            <h3>Operational Metrics with Seismic Events</h3>
            {loading ? (
              <div className="loading">
                <div className="loading-spinner"></div>
                <div>Loading data...</div>
              </div>
            ) : (
              <OperationalChart 
                data={data} 
                selectedVars={selectedVars} 
                dateRange={dateRange}
                showSeismicity={showSeismicity}
                showPhases={showPhases}
                showPits={showPits}
              />
            )}
          </div>
        </div>
      );
    }

    function OperationalChart({ data, selectedVars, dateRange, showSeismicity, showPhases, showPits }) {
      const chartRef = useRef(null);
      const chartInstance = useRef(null);
      const [events, setEvents] = useState([]);
      const [groundTruth, setGroundTruth] = useState([]);
      const [panMode, setPanMode] = useState(false);
      const [zoomMode, setZoomMode] = useState(false);

      useEffect(() => {
        loadEvents();
      }, [dateRange]);

      async function loadEvents() {
        try {
          const eventsResult = await fetchAPI(
            `/data/events?start_date=${dateRange.start}&end_date=${dateRange.end}&threshold=0.997957`
          );
          setEvents(eventsResult.events || []);
          
          // Check if ground truth available
          if (eventsResult.events && eventsResult.events.length > 0 && eventsResult.events[0].magnitude_actual !== undefined) {
            setGroundTruth(eventsResult.events.filter(e => e.magnitude_actual > 0));
          }
        } catch (err) {
          console.error('Error loading events:', err);
        }
      }

      useEffect(() => {
        if (!chartRef.current || !data.length) return;

        // Destroy previous chart
        if (chartInstance.current) {
          chartInstance.current.destroy();
        }

        const ctx = chartRef.current.getContext('2d');

        // Prepare operational datasets
        const datasets = selectedVars.map((varKey, idx) => ({
          label: OPERATIONAL_VARS[varKey],
          data: data.map(d => ({
            x: d.timestamp,
            y: parseFloat(d[varKey]) || 0
          })),
          borderColor: CHART_COLORS[idx % CHART_COLORS.length],
          backgroundColor: CHART_COLORS[idx % CHART_COLORS.length] + '20',
          borderWidth: 1.5,
          tension: 0.4,
          fill: false,
          pointRadius: 0,
          pointHoverRadius: 5,
          yAxisID: 'y',
        }));

        // Add predicted events as scatter on secondary axis - colored by classification
        if (showSeismicity && events.length > 0) {
          const yellowEvents = events.filter(e => e.traffic_light === 'YELLOW');
          const redEvents = events.filter(e => e.traffic_light === 'RED');

          if (yellowEvents.length > 0) {
            datasets.push({
              label: 'üü° Yellow Events',
              data: yellowEvents.map(e => ({
                x: e.timestamp,
                y: e.magnitude_predicted,
                eventData: e  // Store full event data
              })),
              type: 'scatter',
              backgroundColor: 'rgba(245, 158, 11, 0.7)',
              borderColor: '#f59e0b',
              borderWidth: 1,
              pointRadius: 5,
              pointStyle: 'rectRot',
              pointHoverRadius: 7,
              yAxisID: 'y2',
            });
          }

          if (redEvents.length > 0) {
            datasets.push({
              label: 'üî¥ Red Events',
              data: redEvents.map(e => ({
                x: e.timestamp,
                y: e.magnitude_predicted,
                eventData: e  // Store full event data
              })),
              type: 'scatter',
              backgroundColor: 'rgba(239, 68, 68, 0.7)',
              borderColor: '#ef4444',
              borderWidth: 1,
              pointRadius: 6,
              pointStyle: 'star',
              pointHoverRadius: 8,
              yAxisID: 'y2',
            });
          }
        }

        // Add actual events if available
        if (groundTruth.length > 0) {
          datasets.push({
            label: '‚úñÔ∏è Actual Events',
            data: groundTruth.map(e => ({
              x: e.timestamp,
              y: e.magnitude_actual
            })),
            type: 'scatter',
            backgroundColor: '#000000',
            borderColor: '#000000',
            borderWidth: 3,
            pointRadius: 8,
            pointStyle: 'crossRot',
            pointHoverRadius: 12,
            yAxisID: 'y2',
          });
        }

        chartInstance.current = new Chart(ctx, {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'nearest',
              intersect: false,
              axis: 'x'
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  minUnit: 'hour',
                  displayFormats: {
                    millisecond: 'HH:mm:ss.SSS',
                    second: 'HH:mm:ss',
                    minute: 'HH:mm',
                    hour: 'MMM d, HH:mm',
                    day: 'MMM d',
                    week: 'MMM d',
                    month: 'MMM yyyy',
                    quarter: 'MMM yyyy',
                    year: 'yyyy'
                  },
                  tooltipFormat: 'MMM d, yyyy HH:mm:ss'
                },
                title: {
                  display: true,
                  text: 'Time',
                  font: { size: 12, weight: 'bold' }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                },
                ticks: {
                  autoSkip: true,
                  maxRotation: 45,
                  minRotation: 0
                }
              },
              y: {
                beginAtZero: false,
                position: 'left',
                title: {
                  display: true,
                  text: 'Operational Metrics',
                  font: { size: 12, weight: 'bold' },
                  color: '#3B82F6'
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                }
              },
              y2: {
                beginAtZero: true,
                position: 'right',
                title: {
                  display: true,
                  text: 'Event Magnitude',
                  font: { size: 12, weight: 'bold' },
                  color: '#f59e0b'
                },
                grid: {
                  display: false
                },
                max: 3
              }
            },
            plugins: {
              legend: {
                position: 'top',
                labels: { 
                  usePointStyle: true,
                  padding: 15,
                  font: { size: 12 }
                }
              },
              tooltip: {
                enabled: true,
                mode: 'nearest',
                intersect: true,
                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                titleFont: { size: 14, weight: 'bold' },
                bodyFont: { size: 12 },
                bodySpacing: 6,
                padding: 12,
                displayColors: false,
                filter: function(tooltipItem) {
                  // Only show tooltip for event datasets (scatter points with eventData)
                  return tooltipItem.raw && tooltipItem.raw.eventData !== undefined;
                },
                callbacks: {
                  title: function(tooltipItems) {
                    if (tooltipItems.length > 0) {
                      const date = new Date(tooltipItems[0].parsed.x);
                      return date.toLocaleString('en-US', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                      });
                    }
                    return '';
                  },
                  label: function(context) {
                    // Check if this is an event marker (has eventData)
                    const dataPoint = context.raw;
                    if (dataPoint && dataPoint.eventData) {
                      const e = dataPoint.eventData;
                      const lines = [
                        `‚ö†Ô∏è SEISMIC EVENT`,
                        `Probability: ${e.event_probability?.toFixed(4) || 'N/A'}`,
                        `Magnitude: ${e.magnitude_predicted?.toFixed(3) || 'N/A'}`,
                        `Risk: ${e.traffic_light || 'N/A'}`
                      ];
                      
                      // Add operational variables if available
                      if (e.inj_whp !== undefined) lines.push(`Injection Pressure (bar): ${e.inj_whp.toFixed(2)}`);
                      if (e.prod_whp !== undefined) lines.push(`Production Pressure (bar): ${e.prod_whp.toFixed(2)}`);
                      if (e.inj_temp !== undefined) lines.push(`Injection Temperature (¬∞C): ${e.inj_temp.toFixed(2)}`);
                      
                      // Add ground truth if available
                      if (e.magnitude_actual !== undefined && e.magnitude_actual > 0) {
                        lines.push(`Actual Mag: ${e.magnitude_actual.toFixed(3)}`);
                      }
                      
                      return lines;
                    }
                    
                    // Regular data point
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    label += context.parsed.y.toFixed(2);
                    return label;
                  }
                }
              },
              zoom: {
                limits: {
                  x: {min: 'original', max: 'original'}
                },
                zoom: {
                  wheel: {
                    enabled: !zoomMode,
                    speed: 0.1,
                    modifierKey: null
                  },
                  pinch: {
                    enabled: true
                  },
                  drag: {
                    enabled: zoomMode,
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderColor: 'rgba(59, 130, 246, 0.8)',
                    borderWidth: 1
                  },
                  mode: 'x'
                },
                pan: {
                  enabled: panMode,
                  mode: 'x',
                  modifierKey: null,
                  threshold: 10
                }
              }
            }
          }
        });

        return () => {
          if (chartInstance.current) {
            chartInstance.current.destroy();
          }
        };
      }, [data, selectedVars, events, groundTruth, panMode, zoomMode, showSeismicity, showPhases, showPits]);

      const downloadChart = () => {
        if (chartRef.current) {
          const url = chartRef.current.toDataURL('image/png');
          const link = document.createElement('a');
          link.download = `seismic-chart-${new Date().toISOString().split('T')[0]}.png`;
          link.href = url;
          link.click();
        }
      };

      const zoomIn = () => {
        if (chartInstance.current) {
          chartInstance.current.zoom(1.2);
        }
      };

      const zoomOut = () => {
        if (chartInstance.current) {
          chartInstance.current.zoom(0.8);
        }
      };

      const resetZoom = () => {
        if (chartInstance.current) {
          chartInstance.current.resetZoom();
        }
      };

      const togglePan = () => {
        setPanMode(!panMode);
        setZoomMode(false);
      };

      const toggleZoomBox = () => {
        setZoomMode(!zoomMode);
        setPanMode(false);
      };

      const autoScale = () => {
        if (chartInstance.current) {
          chartInstance.current.resetZoom();
          chartInstance.current.update('none');
        }
      };

      if (!data.length) {
        return <div className="loading">No data available for selected date range</div>;
      }

      return (
        <div>
          {/* Toolbar */}
          <div className="chart-toolbar">
            <button onClick={downloadChart} title="Download chart as PNG">üì∑</button>
            <button onClick={zoomIn} title="Zoom in">üîç+</button>
            <button onClick={zoomOut} title="Zoom out">üîç-</button>
            <button 
              onClick={togglePan} 
              className={panMode ? 'active' : ''}
              title="Pan mode"
            >‚úã</button>
            <button 
              onClick={toggleZoomBox} 
              className={zoomMode ? 'active' : ''}
              title="Box zoom"
            >‚ñ≠</button>
            <button onClick={resetZoom} title="Reset zoom">üè†</button>
            <button onClick={autoScale} title="Autoscale">‚ö°</button>
          </div>
          
          {/* Chart */}
          <div style={{position: 'relative', height: '450px', width: '100%'}}>
            <canvas ref={chartRef}></canvas>
          </div>
        </div>
      );
    }

    // =================================================================
    // RISK DASHBOARD
    // =================================================================

    function RiskDashboard({ dataInfo }) {
      const [statistics, setStatistics] = useState(null);
      const [events, setEvents] = useState([]);
      const [loading, setLoading] = useState(false);
      const [threshold, setThreshold] = useState(0.997957);
      const [showEventTable, setShowEventTable] = useState(false);
      const [dateRange, setDateRange] = useState({
        start: dataInfo?.min_date?.split('T')[0] || '',
        end: dataInfo?.max_date?.split('T')[0] || ''
      });

      useEffect(() => {
        loadRiskData();
      }, [dateRange, threshold]);

      async function loadRiskData() {
        try {
          setLoading(true);
          
          // Get statistics
          const stats = await fetchAPI(
            `/statistics?start_date=${dateRange.start}&end_date=${dateRange.end}&threshold=${threshold}`
          );
          setStatistics(stats);

          // Get events
          const eventsResult = await fetchAPI(
            `/data/events?start_date=${dateRange.start}&end_date=${dateRange.end}&threshold=${threshold}`
          );
          setEvents(eventsResult.events || []);
          
          setLoading(false);
        } catch (err) {
          console.error('Error loading risk data:', err);
          setLoading(false);
        }
      }

      return (
        <div>
          {/* Controls */}
          <div className="controls">
            <div className="controls-grid">
              <div className="control-item">
                <label>Start Date</label>
                <input
                  type="date"
                  value={dateRange.start}
                  onChange={(e) => setDateRange({...dateRange, start: e.target.value})}
                />
              </div>
              <div className="control-item">
                <label>End Date</label>
                <input
                  type="date"
                  value={dateRange.end}
                  onChange={(e) => setDateRange({...dateRange, end: e.target.value})}
                />
              </div>
              <div className="control-item">
                <label>Event Threshold</label>
                <input
                  type="number"
                  min="0"
                  max="1"
                  step="0.01"
                  value={threshold}
                  onChange={(e) => setThreshold(parseFloat(e.target.value))}
                />
              </div>
            </div>
          </div>

          {loading ? (
            <div className="loading">
              <div className="loading-spinner"></div>
              <div>Loading risk data...</div>
            </div>
          ) : (
            <>
              {/* KPIs */}
              {statistics && (
                <div className="kpis">
                  <div className="kpi-card">
                    <h4>Total Samples</h4>
                    <div className="kpi-value">{statistics.total_samples?.toLocaleString()}</div>
                  </div>
                  <div className="kpi-card">
                    <h4>Events Detected</h4>
                    <div className="kpi-value" style={{color: '#ef4444'}}>
                      {statistics.events_detected?.toLocaleString()}
                    </div>
                  </div>
                  <div className="kpi-card">
                    <h4>Max Magnitude</h4>
                    <div className="kpi-value" style={{color: '#f59e0b'}}>
                      {statistics.max_magnitude?.toFixed(3)}
                    </div>
                  </div>
                  <div className="kpi-card">
                    <h4>üü¢ Green</h4>
                    <div className="kpi-value" style={{color: '#10b981'}}>
                      {statistics.green_count?.toLocaleString()}
                    </div>
                  </div>
                  <div className="kpi-card">
                    <h4>üü° Yellow</h4>
                    <div className="kpi-value" style={{color: '#f59e0b'}}>
                      {statistics.yellow_count?.toLocaleString()}
                    </div>
                  </div>
                  <div className="kpi-card">
                    <h4>üî¥ Red</h4>
                    <div className="kpi-value" style={{color: '#ef4444'}}>
                      {statistics.red_count?.toLocaleString()}
                    </div>
                  </div>
                </div>
              )}

              {/* Event Table */}
              <div className="chart-container">
                <div style={{display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '15px'}}>
                  <h3 style={{margin: 0}}>‚ö†Ô∏è Detected Seismic Events ({events.length})</h3>
                  <button 
                    onClick={() => setShowEventTable(!showEventTable)}
                    style={{
                      padding: '10px 20px',
                      backgroundColor: '#667eea',
                      color: 'white',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer',
                      fontSize: '14px',
                      fontWeight: '600',
                      transition: 'all 0.3s ease',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                    }}
                    onMouseOver={(e) => e.target.style.backgroundColor = '#5568d3'}
                    onMouseOut={(e) => e.target.style.backgroundColor = '#667eea'}
                  >
                    {showEventTable ? '‚ñº Hide Table' : '‚ñ∂ Show Test Data (' + events.length + ' records)'}
                  </button>
                </div>
                {showEventTable && events.length > 0 ? (
                  <div style={{overflowX: 'auto'}}>
                    <table className="event-table">
                      <thead>
                        <tr>
                          <th>Time</th>
                          <th>Probability</th>
                          <th>Magnitude</th>
                          <th>Risk Level</th>
                        </tr>
                      </thead>
                      <tbody>
                        {events.slice(0, 50).map((event, idx) => {
                          const trafficConfig = TRAFFIC_CONFIG[event.traffic_light_pred];
                          return (
                            <tr key={idx}>
                              <td>{event.timestamp}</td>
                              <td>{(event.event_probability * 100).toFixed(2)}%</td>
                              <td>{event.magnitude_predicted?.toFixed(3)}</td>
                              <td>
                                <span 
                                  className={`traffic-badge traffic-${trafficConfig?.label.toLowerCase()}`}
                                >
                                  {trafficConfig?.icon} {trafficConfig?.label}
                                </span>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                    {events.length > 50 && (
                      <p style={{marginTop: '15px', color: '#64748b', fontSize: '14px'}}>
                        Showing first 50 of {events.length} events
                      </p>
                    )}
                  </div>
                ) : showEventTable && events.length === 0 ? (
                  <div className="loading">‚úÖ No events detected in this period</div>
                ) : null}
              </div>

              {/* Confusion Matrix */}
              {statistics?.confusion_matrix && statistics?.metrics && (
                <div className="chart-container">
                  <h3>üß† CONFUSION MATRIX</h3>
                  <div className="kpis" style={{gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))'}}>
                    <div className="kpi-card" style={{borderTop: '4px solid #10b981'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>‚úÖ</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>TRUE NEGATIVE</h4>
                      <div className="kpi-value" style={{color: '#10b981', fontSize: '36px'}}>{statistics.confusion_matrix.tn.toLocaleString()}</div>
                      <p style={{fontSize: '11px', color: '#94a3b8', marginTop: '8px'}}>Actual: No | Pred: No</p>
                    </div>
                    <div className="kpi-card" style={{borderTop: '4px solid #ef4444'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>‚ùå</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>FALSE POSITIVE</h4>
                      <div className="kpi-value" style={{color: '#ef4444', fontSize: '36px'}}>{statistics.confusion_matrix.fp.toLocaleString()}</div>
                      <p style={{fontSize: '11px', color: '#94a3b8', marginTop: '8px'}}>Actual: No | Pred: Event</p>
                    </div>
                    <div className="kpi-card" style={{borderTop: '4px solid #ef4444'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>‚ö†Ô∏è</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>FALSE NEGATIVE</h4>
                      <div className="kpi-value" style={{color: '#ef4444', fontSize: '36px'}}>{statistics.confusion_matrix.fn.toLocaleString()}</div>
                      <p style={{fontSize: '11px', color: '#94a3b8', marginTop: '8px'}}>Actual: Event | Pred: No</p>
                    </div>
                    <div className="kpi-card" style={{borderTop: '4px solid #10b981'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>‚úÖ</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>TRUE POSITIVE</h4>
                      <div className="kpi-value" style={{color: '#10b981', fontSize: '36px'}}>{statistics.confusion_matrix.tp.toLocaleString()}</div>
                      <p style={{fontSize: '11px', color: '#94a3b8', marginTop: '8px'}}>Actual: Event | Pred: Event</p>
                    </div>
                  </div>
                </div>
              )}

              {/* Model Performance Metrics */}
              {statistics?.metrics && (
                <div className="chart-container">
                  <h3>üéØ MODEL PERFORMANCE METRICS</h3>
                  <div className="kpis">
                    <div className="kpi-card" style={{borderTop: '4px solid #10b981'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>üéØ</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>ACCURACY</h4>
                      <div className="kpi-value" style={{color: '#10b981', fontSize: '36px'}}>{(statistics.metrics.accuracy * 100).toFixed(2)}%</div>
                    </div>
                    <div className="kpi-card" style={{borderTop: '4px solid #3b82f6'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>üìä</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>PRECISION</h4>
                      <div className="kpi-value" style={{color: '#3b82f6', fontSize: '36px'}}>{(statistics.metrics.precision * 100).toFixed(2)}%</div>
                    </div>
                    <div className="kpi-card" style={{borderTop: '4px solid #8b5cf6'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>üîç</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>RECALL</h4>
                      <div className="kpi-value" style={{color: '#8b5cf6', fontSize: '36px'}}>{(statistics.metrics.recall * 100).toFixed(2)}%</div>
                    </div>
                    <div className="kpi-card" style={{borderTop: '4px solid #f59e0b'}}>
                      <div style={{fontSize: '32px', marginBottom: '10px'}}>‚≠ê</div>
                      <h4 style={{color: '#64748b', fontSize: '12px', textTransform: 'uppercase', letterSpacing: '1px'}}>F1-SCORE</h4>
                      <div className="kpi-value" style={{color: '#f59e0b', fontSize: '36px'}}>{(statistics.metrics.f1_score * 100).toFixed(2)}%</div>
                    </div>
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      );
    }

    // =================================================================
    // RISK TIMELINE CHART
    // =================================================================

    function RiskTimelineChart({ startDate, endDate, threshold }) {
      const chartRef = useRef(null);
      const chartInstance = useRef(null);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        loadAndRenderChart();
      }, [startDate, endDate, threshold]);

      async function loadAndRenderChart() {
        try {
          setLoading(true);
          
          // Fetch operational data with traffic light predictions
          const variables = 'inj_whp,prod_whp,inj_temp';
          const result = await fetchAPI(
            `/data/operational?start_date=${startDate}&end_date=${endDate}&variables=${variables}`
          );
          
          if (!chartRef.current || !result.data || result.data.length === 0) {
            setLoading(false);
            return;
          }

          // Destroy previous chart
          if (chartInstance.current) {
            chartInstance.current.destroy();
          }

          const ctx = chartRef.current.getContext('2d');
          const data = result.data;

          // Separate data by traffic light level
          const greenData = [];
          const yellowData = [];
          const redData = [];

          data.forEach(d => {
            const point = {
              x: d.timestamp,
              y: d.event_probability * 100 // Convert to percentage
            };
            
            if (d.traffic_light_pred === 0) {
              greenData.push(point);
            } else if (d.traffic_light_pred === 1) {
              yellowData.push(point);
            } else if (d.traffic_light_pred === 2) {
              redData.push(point);
            }
          });

          chartInstance.current = new Chart(ctx, {
            type: 'scatter',
            data: {
              datasets: [
                {
                  label: 'üü¢ GREEN (Safe)',
                  data: greenData,
                  backgroundColor: 'rgba(16, 185, 129, 0.6)',
                  borderColor: '#10b981',
                  pointRadius: 2,
                  pointHoverRadius: 5,
                },
                {
                  label: 'üü° YELLOW (Warning)',
                  data: yellowData,
                  backgroundColor: 'rgba(245, 158, 11, 0.6)',
                  borderColor: '#f59e0b',
                  pointRadius: 2,
                  pointHoverRadius: 5,
                },
                {
                  label: 'üî¥ RED (Danger)',
                  data: redData,
                  backgroundColor: 'rgba(239, 68, 68, 0.8)',
                  borderColor: '#ef4444',
                  pointRadius: 3,
                  pointHoverRadius: 6,
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'nearest',
                intersect: false,
                axis: 'x'
              },
              scales: {
                x: {
                  type: 'time',
                  time: {
                    unit: 'hour',
                    displayFormats: {
                      hour: 'MMM d, HH:mm'
                    }
                  },
                  title: {
                    display: true,
                    text: 'Time',
                    font: { size: 12, weight: 'bold' }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                },
                y: {
                  beginAtZero: true,
                  max: 100,
                  title: {
                    display: true,
                    text: 'Event Probability (%)',
                    font: { size: 12, weight: 'bold' }
                  },
                  grid: {
                    display: true,
                    color: 'rgba(0, 0, 0, 0.05)'
                  }
                }
              },
              plugins: {
                legend: {
                  position: 'top',
                  labels: {
                    usePointStyle: true,
                    padding: 15,
                    font: { size: 12 }
                  }
                },
                tooltip: {
                  enabled: true,
                  backgroundColor: 'rgba(0, 0, 0, 0.8)',
                  titleFont: { size: 13, weight: 'bold' },
                  bodyFont: { size: 12 },
                  padding: 12,
                  displayColors: true,
                  callbacks: {
                    title: function(tooltipItems) {
                      if (tooltipItems.length > 0) {
                        const date = new Date(tooltipItems[0].parsed.x);
                        return date.toLocaleString('en-US', { 
                          year: 'numeric', 
                          month: 'short', 
                          day: 'numeric',
                          hour: '2-digit',
                          minute: '2-digit'
                        });
                      }
                      return '';
                    },
                    label: function(context) {
                      return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                    }
                  }
                },
                zoom: {
                  zoom: {
                    wheel: { enabled: true },
                    pinch: { enabled: true },
                    mode: 'x',
                  },
                  pan: {
                    enabled: true,
                    mode: 'x',
                  }
                }
              }
            }
          });

          setLoading(false);
        } catch (err) {
          console.error('Error loading risk timeline:', err);
          setLoading(false);
        }
      }

      if (loading) {
        return (
          <div className="loading">
            <div className="loading-spinner"></div>
            <div>Loading risk timeline...</div>
          </div>
        );
      }

      return (
        <div style={{position: 'relative', height: '450px', width: '100%'}}>
          <canvas ref={chartRef}></canvas>
        </div>
      );
    }

    // =================================================================
    // EVENT SCATTER CHART
    // =================================================================

    function EventScatterChart({ events }) {
      const chartRef = useRef(null);
      const chartInstance = useRef(null);

      useEffect(() => {
        if (!chartRef.current || !events.length) return;

        // Destroy previous chart
        if (chartInstance.current) {
          chartInstance.current.destroy();
        }

        const ctx = chartRef.current.getContext('2d');

        // Separate events by risk level
        const greenEvents = [];
        const yellowEvents = [];
        const redEvents = [];

        events.forEach(event => {
          const point = {
            x: event.timestamp,
            y: event.magnitude_predicted,
            probability: event.event_probability
          };
          
          if (event.traffic_light_pred === 0) {
            greenEvents.push(point);
          } else if (event.traffic_light_pred === 1) {
            yellowEvents.push(point);
          } else if (event.traffic_light_pred === 2) {
            redEvents.push(point);
          }
        });

        chartInstance.current = new Chart(ctx, {
          type: 'scatter',
          data: {
            datasets: [
              {
                label: 'üü¢ GREEN Events',
                data: greenEvents,
                backgroundColor: 'rgba(16, 185, 129, 0.6)',
                borderColor: '#10b981',
                borderWidth: 1,
                pointRadius: 3,
                pointHoverRadius: 7,
              },
              {
                label: 'üü° YELLOW Events',
                data: yellowEvents,
                backgroundColor: 'rgba(245, 158, 11, 0.6)',
                borderColor: '#f59e0b',
                borderWidth: 1,
                pointRadius: 3,
                pointHoverRadius: 7,
              },
              {
                label: 'üî¥ RED Events',
                data: redEvents,
                backgroundColor: 'rgba(239, 68, 68, 0.8)',
                borderColor: '#ef4444',
                borderWidth: 1,
                pointRadius: 4,
                pointHoverRadius: 8,
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'nearest',
              intersect: false,
              axis: 'x'
            },
            scales: {
              x: {
                type: 'time',
                time: {
                  unit: 'hour',
                  displayFormats: {
                    hour: 'MMM d, HH:mm'
                  }
                },
                title: {
                  display: true,
                  text: 'Time',
                  font: { size: 12, weight: 'bold' }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                }
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Magnitude',
                  font: { size: 12, weight: 'bold' }
                },
                grid: {
                  display: true,
                  color: 'rgba(0, 0, 0, 0.05)'
                }
              }
            },
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  usePointStyle: true,
                  padding: 15,
                  font: { size: 12 }
                }
              },
              tooltip: {
                enabled: true,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleFont: { size: 13, weight: 'bold' },
                bodyFont: { size: 12 },
                bodySpacing: 6,
                padding: 12,
                displayColors: true,
                callbacks: {
                  title: function(tooltipItems) {
                    if (tooltipItems.length > 0) {
                      const date = new Date(tooltipItems[0].parsed.x);
                      return date.toLocaleString('en-US', { 
                        year: 'numeric', 
                        month: 'short', 
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                      });
                    }
                    return '';
                  },
                  label: function(context) {
                    const dataPoint = context.raw;
                    return [
                      'Magnitude: ' + context.parsed.y.toFixed(3),
                      'Probability: ' + (dataPoint.probability * 100).toFixed(2) + '%'
                    ];
                  }
                }
              },
              zoom: {
                zoom: {
                  wheel: { enabled: true },
                  pinch: { enabled: true },
                  mode: 'xy',
                },
                pan: {
                  enabled: true,
                  mode: 'xy',
                }
              },
              annotation: {
                annotations: {
                  yellowLine: {
                    type: 'line',
                    yMin: 0.17,
                    yMax: 0.17,
                    borderColor: '#f59e0b',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    label: {
                      content: 'YELLOW Threshold (0.17)',
                      enabled: true,
                      position: 'end',
                      backgroundColor: 'rgba(245, 158, 11, 0.8)',
                      color: 'white',
                      font: { size: 10 }
                    }
                  },
                  redLine: {
                    type: 'line',
                    yMin: 1.0,
                    yMax: 1.0,
                    borderColor: '#ef4444',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    label: {
                      content: 'RED Threshold (1.0)',
                      enabled: true,
                      position: 'end',
                      backgroundColor: 'rgba(239, 68, 68, 0.8)',
                      color: 'white',
                      font: { size: 10 }
                    }
                  }
                }
              }
            }
          }
        });

        return () => {
          if (chartInstance.current) {
            chartInstance.current.destroy();
          }
        };
      }, [events]);

      return (
        <div style={{position: 'relative', height: '450px', width: '100%'}}>
          <canvas ref={chartRef}></canvas>
        </div>
      );
    }

    // =================================================================
    // RENDER APP
    // =================================================================

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);

  </script>
</body>
</html>
