<!DOCTYPE html>
<!--
  ============================================================================
  GEOTHERMAL PLANT MONITORING DASHBOARD
  ============================================================================
  
  Purpose: Real-time monitoring and seismic risk prediction dashboard for 
           geothermal power plant operations.
  
  Features:
  - Operational metrics visualization (flow, pressure, temperature)
  - Seismic activity monitoring (magnitude, event counts)
  - LSTM-based 2-day risk forecast
  - Interactive time-series charts with zoom/pan
  - Real-time data from CSV files via Flask API
  - Metric selection checkboxes for customizable views
  
  Tech Stack:
  - Frontend: React 18 (CDN), Chart.js 4.4, Babel (JSX transpilation)
  - Backend: Flask API with TensorFlow/Keras LSTM model
  - Data: CSV files (operational_metrics.csv, seismic_events.csv)
  
  Author: Data Science Project - Hasselt University
  Date: 2025
  ============================================================================
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React Dashboard - Geothermal Monitoring</title>
  
  <!-- React 18 via CDN - Core UI framework -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone - Transpiles JSX to JavaScript in browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Chart.js 4.4 - Time-series data visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <!-- Chart.js Zoom Plugin - Enables zoom and pan interactions -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  
  <!-- React-Chartjs-2 adapter - React wrapper for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/react-chartjs-2@5.2.0/dist/index.umd.min.js"></script>
  
  <!-- PapaParse - CSV file parsing (for client-side data loading if needed) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  
  <!-- Google Fonts - Inter font family for modern UI -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  
  <style>
    * { 
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body { 
      margin: 0; 
      padding: 0; 
      height: 100%; 
      overflow-x: hidden;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
      color: #1a202c;
      min-height: 100vh;
    }
    
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    #root { 
      min-height: 100vh;
      padding: 20px;
    }
    
    .container { 
      max-width: 1600px; 
      margin: 0 auto; 
      padding: 0;
    }
    
    /* Enhanced Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 30px;
      padding: 25px 30px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .logo { 
      font-size: 28px; 
      font-weight: 800; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.5px;
    }
    
    .subtitle { 
      color: #64748b; 
      font-size: 14px;
      font-weight: 500;
      margin-top: 4px;
    }
    
    /* Enhanced Navigation Tabs */
    .nav-tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 25px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 8px;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }
    
    .nav-tab {
      padding: 14px 28px;
      border: none;
      background: transparent;
      cursor: pointer;
      border-radius: 12px;
      font-weight: 600;
      font-size: 15px;
      color: #64748b;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }
    
    .nav-tab:hover { 
      background: rgba(102, 126, 234, 0.1); 
      color: #667eea;
      transform: translateY(-2px);
    }
    
    .nav-tab.active { 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      transform: translateY(-2px);
    }
    
    /* Enhanced KPI Cards */
    .kpis {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .kpi-card {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 28px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      border: 1px solid rgba(255, 255, 255, 0.5);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .kpi-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .kpi-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    
    .kpi-card:hover::before {
      opacity: 1;
    }
    
    .kpi-card h4 {
      font-size: 12px;
      font-weight: 700;
      color: #64748b;
      margin: 0 0 12px 0;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .kpi-value {
      font-size: 36px;
      font-weight: 800;
      color: #1e293b;
      margin: 0;
      line-height: 1.2;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Enhanced Chart Container */
    .chart-container {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 24px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      margin-bottom: 25px;
      position: relative;
      min-height: 500px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }
    
    .chart-container canvas {
      max-height: 450px !important;
      width: 100% !important;
    }
    
    .chart-container h3 {
      font-size: 18px;
      font-weight: 700;
      margin: 0 0 25px 0;
      color: #1e293b;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Enhanced Date Selector */
    .date-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 25px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }
    
    @media (max-width: 768px) {
      .date-selector {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    .date-input {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .date-input label {
      font-size: 12px;
      font-weight: 700;
      color: #475569;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .date-input input {
      padding: 12px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-size: 14px;
      transition: all 0.3s;
      background: white;
    }
    
    .date-input input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    
    /* Enhanced Risk Indicator */
    .risk-indicator {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      margin: 0 auto 25px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 56px;
      font-weight: 800;
      border: 12px solid;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }
    
    .risk-indicator::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
      animation: shimmer 3s infinite;
    }
    
    @keyframes shimmer {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .risk-indicator:hover {
      transform: scale(1.05);
      box-shadow: 0 25px 70px rgba(0, 0, 0, 0.4);
    }
    
    .risk-low {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-color: #047857;
      color: white;
    }
    
    .risk-medium {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      border-color: #b45309;
      color: white;
    }
    
    .risk-high {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      border-color: #b91c1c;
      color: white;
    }
    
    /* Status Banner Enhancement */
    .status-banner {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 30px;
      border-radius: 16px;
      margin-bottom: 25px;
      box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    /* Metric Checkboxes Enhancement */
    .metrics-grid {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      margin-bottom: 25px;
    }
    
    /* Button Enhancements */
    button {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 10px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }
    
    /* Loading Animation */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .loading {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    
    /* Card Hover Effects */
    .card-hover {
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .card-hover:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }
    
    /* Responsive Design */
    @media (max-width: 1024px) {
      .container {
        padding: 15px;
      }
      
      header {
        padding: 20px;
        flex-direction: column;
        align-items: flex-start;
        gap: 15px;
      }
      
      .kpis {
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
      }
    }
    
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      .kpis {
        grid-template-columns: 1fr;
      }
      
      /* Fix zoom controls on mobile - wrap buttons */
      .chart-container > div:first-child {
        flex-direction: column !important;
        align-items: flex-start !important;
        gap: 10px !important;
      }
      
      .chart-container > div:first-child > div:last-child {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        width: 100%;
      }
      
      .chart-container > div:first-child > div:last-child button {
        flex: 1 1 auto;
        min-width: 60px;
        padding: 8px 10px !important;
        font-size: 11px !important;
      }
      
      /* Fix risk dashboard layout on mobile - stack vertically */
      .risk-dashboard-flex {
        flex-direction: column !important;
      }
      
      .risk-dashboard-flex > div {
        flex: 1 1 auto !important;
        width: 100% !important;
        margin-bottom: 20px;
      }
      
      /* Make risk indicator smaller on mobile */
      .risk-indicator {
        width: 120px !important;
        height: 120px !important;
        font-size: 50px !important;
      }
      
      .chart-container {
        padding: 20px;
        min-height: 400px;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    // Wait for React to be fully loaded
    if (typeof React === 'undefined') {
      console.error('React is not loaded!');
      document.getElementById('root').innerHTML = '<div style="padding: 20px;">Loading React...</div>';
    }
    
    const { useState, useEffect, useRef } = React;
    
    // API Client
    const API_BASE_URL = 'https://geothermal-api.onrender.com';
    
    // ============================================================================
    // API CLIENT CLASS
    // ============================================================================
    // Handles all communication with the Flask backend API
    // Provides methods for health checks, data fetching, and model predictions
    // ============================================================================
    class SeismicRiskAPI {
      constructor(baseURL = API_BASE_URL) {
        // API base URL - points to Flask server running on port 5000
        this.baseURL = baseURL;
        // Browser caching for faster repeat visits
        this.CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
        this.loadCache();
      }
      
      // Load cache from localStorage
      loadCache() {
        try {
          const cached = localStorage.getItem('api_cache');
          if (cached) {
            this.cache = JSON.parse(cached);
            // Check if cache is expired
            const now = Date.now();
            if (this.cache.health && (now - this.cache.healthTime) > this.CACHE_DURATION) {
              this.cache.health = null;
            }
          } else {
            this.cache = { health: null, healthTime: 0 };
          }
        } catch (e) {
          this.cache = { health: null, healthTime: 0 };
        }
      }
      
      // Save cache to localStorage
      saveCache() {
        try {
          localStorage.setItem('api_cache', JSON.stringify(this.cache));
        } catch (e) {
          // Ignore if localStorage is not available
        }
      }
      
      async healthCheck(retries = 10, delay = 1000, onProgress = null) {
        // Check cache first (faster for repeat visits)
        const now = Date.now();
        if (this.cache.health && (now - this.cache.healthTime) < this.CACHE_DURATION) {
          console.log('‚úÖ Using cached health check');
          if (onProgress) {
            onProgress(retries, retries, 0); // Show as complete
          }
          return this.cache.health;
        }
        
        // Retry logic with faster initial delay (1s instead of 3s) for cold starts
        for (let i = 0; i < retries; i++) {
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout per attempt
            
            if (onProgress) {
              onProgress(i + 1, retries, delay);
            }
            
            const response = await fetch(`${this.baseURL}/health`, {
              signal: controller.signal,
              cache: 'no-cache'
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
              const result = await response.json();
              // Cache successful health check
              this.cache.health = result;
              this.cache.healthTime = Date.now();
              this.saveCache();
              return result;
            }
            
            // If not OK, wait and retry
            if (i < retries - 1) {
              await new Promise(resolve => setTimeout(resolve, delay));
              delay = Math.min(delay * 1.5, 5000); // Faster backoff (1.5x instead of 1.2x)
            }
          } catch (error) {
            if (error.name === 'AbortError') {
              console.log(`‚è±Ô∏è Request timeout (attempt ${i + 1}/${retries})`);
            } else {
              console.log(`‚ö†Ô∏è Attempt ${i + 1}/${retries} failed:`, error.message);
            }
            
            // If last attempt, return error
            if (i === retries - 1) {
              return { status: 'error', error: error.message };
            }
            
            // Wait before retry
            await new Promise(resolve => setTimeout(resolve, delay));
            delay = Math.min(delay * 1.5, 5000); // Faster backoff
          }
        }
        return { status: 'error', error: 'Max retries reached' };
      }
      
      /**
       * Request 2-day seismic risk forecast from LSTM model
       * @param {string} startDate - Starting date for forecast (ISO format)
       * @param {Array} historicalData - Last 24 hours of operational data for model input
       * @returns {Array} 2-day forecast with risk levels and probabilities
       */
      async getForecast(startDate, historicalData) {
        try {
          // Prepare payload for LSTM model prediction
          const payload = {
            start_date: startDate,
            historical_data: historicalData, // Last 24 hours needed for LSTM lookback
          };
          
          // Add timeout for forecast request (model prediction can take time)
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout for model prediction
          
          // Call Flask API endpoint: POST /predict/forecast
          const response = await fetch(`${this.baseURL}/predict/forecast`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
            signal: controller.signal,
            cache: 'no-cache'
          });
          
          clearTimeout(timeoutId);
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Forecast failed');
          }
          const result = await response.json();
          return result.forecast; // Returns array of 2 forecast days
        } catch (error) {
          console.error('Forecast error:', error);
          throw error;
        }
      }
      
      /**
       * Fetch operational metrics data (flow, pressure, temperature) for a date range
       * @param {string} startDate - Start date/time in ISO format
       * @param {string} endDate - End date/time in ISO format
       * @param {number} limit - Maximum number of records to return (default: 1000)
       * @returns {Array} Array of operational data records
       */
      async getOperationalData(startDate, endDate, limit = 1000) {
        try {
          // Build query parameters for date range filtering
          const params = new URLSearchParams({
            start_date: startDate,
            end_date: endDate,
            limit: limit.toString()
          });
          // Call Flask API endpoint: GET /data/operational
          const response = await fetch(`${this.baseURL}/data/operational?${params}`);
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to load operational data');
          }
          const result = await response.json();
          console.log('üìä API Response:', { 
            dataLength: result.data?.length || 0, 
            count: result.count || 0,
            source: result.source || 'unknown',
            message: result.message || 'none'
          });
          return result.data || []; // Return the data array (empty array if missing)
        } catch (error) {
          console.error('‚ùå Operational data error:', error);
          return []; // Return empty array instead of throwing
        }
      }
      
      /**
       * Fetch seismic events data (magnitude, location) for a date range
       * @param {string} startDate - Start date/time in ISO format
       * @param {string} endDate - End date/time in ISO format
       * @returns {Array} Array of seismic event records
       */
      async getSeismicData(startDate, endDate) {
        try {
          const params = new URLSearchParams({
            start_date: startDate,
            end_date: endDate
          });
          const response = await fetch(`${this.baseURL}/data/seismic?${params}`);
          if (!response.ok) {
            // If 404, return empty array instead of throwing
            if (response.status === 404) {
              console.warn('‚ö†Ô∏è No seismic data found for this date range');
              return [];
            }
            const error = await response.json();
            throw new Error(error.error || 'Failed to load seismic data');
          }
          const result = await response.json();
          return result.data || [];
        } catch (error) {
          console.warn('‚ö†Ô∏è Seismic data error:', error.message);
          // Return empty array instead of throwing - allows dashboard to continue
          return [];
        }
      }
    }
    
    const api = new SeismicRiskAPI();
    
    // CSV Data Loader with streaming for large files
    async function loadCSVData(url, sampleSize = null) {
      try {
        console.log(`Loading CSV: ${url}...`);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // For large files, read in chunks
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let text = '';
        let chunk;
        
        // Read first chunk to check size
        chunk = await reader.read();
        if (chunk.done) {
          throw new Error('Empty file');
        }
        
        text += decoder.decode(chunk.value, { stream: true });
        
        // If file is large and we want to sample, read only part of it
        if (sampleSize) {
          let bytesRead = chunk.value.length;
          const maxBytes = sampleSize * 1024 * 1024; // Convert MB to bytes
          
          while (!chunk.done && bytesRead < maxBytes) {
            chunk = await reader.read();
            if (!chunk.done) {
              text += decoder.decode(chunk.value, { stream: true });
              bytesRead += chunk.value.length;
            }
          }
          console.log(`Sampled ${(bytesRead / 1024 / 1024).toFixed(2)}MB from ${url}`);
        } else {
          // Read entire file
          while (!chunk.done) {
            chunk = await reader.read();
            if (!chunk.done) {
              text += decoder.decode(chunk.value, { stream: true });
            }
          }
        }
        
        return new Promise((resolve, reject) => {
          Papa.parse(text, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => {
              console.log(`‚úÖ Loaded ${results.data.length} records from ${url}`);
              resolve(results.data);
            },
            error: (error) => {
              console.error(`‚ùå Parse error for ${url}:`, error);
              reject(error);
            }
          });
        });
      } catch (error) {
        console.error(`‚ùå Error loading CSV from ${url}:`, error.message);
        return [];
      }
    }
    
    // Load and prepare real data for API
    async function loadRealHistoricalData() {
      try {
        // Load operational metrics (sample 10MB for browser - file is 222MB!)
        console.log('üìä Loading real CSV data...');
        const operationalData = await loadCSVData('data/operational_metrics.csv', 10); // Sample 10MB
        const seismicData = await loadCSVData('data/seismic_events.csv'); // Full file (89KB)
        
        if (!operationalData || operationalData.length === 0) {
          console.warn('No operational data loaded');
          return null;
        }
        
        // Get last 24 hours of data
        // Since we sampled the file, take last records and ensure we have enough
        const recentData = operationalData.length >= 24 
          ? operationalData.slice(-24) 
          : operationalData.slice(-operationalData.length);
        
        console.log(`üìà Using ${recentData.length} records for prediction`);
        
        // Group seismic events by hour
        const seismicByHour = {};
        seismicData.forEach(event => {
          if (event.occurred_at) {
            const hour = new Date(event.occurred_at).toISOString().slice(0, 13) + ':00:00';
            if (!seismicByHour[hour]) {
              seismicByHour[hour] = { count: 0, magnitudes: [], pgvs: [] };
            }
            seismicByHour[hour].count++;
            if (event.magnitude) seismicByHour[hour].magnitudes.push(parseFloat(event.magnitude));
            if (event.pgv_max) seismicByHour[hour].pgvs.push(parseFloat(event.pgv_max));
          }
        });
        
        // Format data for API (last 24 hours)
        const formattedData = recentData.map(record => {
          const timestamp = record.recorded_at || record.timestamp;
          const hour = timestamp ? new Date(timestamp).toISOString().slice(0, 13) + ':00:00' : null;
          const seismic = hour ? seismicByHour[hour] : null;
          
          return {
            timestamp: timestamp || new Date().toISOString(),
            inj_flow: parseFloat(record.inj_flow) || 0,
            inj_whp: parseFloat(record.inj_whp) || 0,
            inj_temp: parseFloat(record.inj_temp) || 0,
            prod_temp: parseFloat(record.prod_temp) || 0,
            prod_whp: parseFloat(record.prod_whp) || 0,
            event_count: seismic ? seismic.count : 0,
            max_magnitude: seismic && seismic.magnitudes.length > 0 ? Math.max(...seismic.magnitudes) : 0,
            avg_magnitude: seismic && seismic.magnitudes.length > 0 ? 
              seismic.magnitudes.reduce((a, b) => a + b, 0) / seismic.magnitudes.length : 0,
            max_pgv: seismic && seismic.pgvs.length > 0 ? Math.max(...seismic.pgvs) : 0,
            avg_pgv: seismic && seismic.pgvs.length > 0 ? 
              seismic.pgvs.reduce((a, b) => a + b, 0) / seismic.pgvs.length : 0,
          };
        });
        
        // Ensure we have exactly 24 hours of data
        if (formattedData.length < 24) {
          console.warn(`Only ${formattedData.length} records, padding with last values`);
          while (formattedData.length < 24) {
            formattedData.unshift(formattedData[0] || formattedData[formattedData.length - 1]);
          }
        }
        
        return formattedData.slice(-24); // Return last 24 hours
      } catch (error) {
        console.error('Error loading real data:', error);
        return null;
      }
    }
    
    // Enhanced KPI Card Component
    function KPICard({ title, value, color, subtitle }) {
      // For risk level text, use solid color for better visibility
      const isRiskLevel = typeof value === 'string' && ['LOW', 'MEDIUM', 'YELLOW', 'ORANGE', 'RED', 'HIGH'].includes(value.toUpperCase());
      
      return (
        <div className="kpi-card card-hover" style={{
          borderTop: `4px solid ${color}`,
          position: 'relative'
        }}>
          <h4 style={{ 
            fontSize: '12px', 
            color: '#64748b', 
            margin: '0 0 12px 0',
            fontWeight: '700',
            textTransform: 'uppercase',
            letterSpacing: '1px'
          }}>
            {title}
          </h4>
          <p className="kpi-value" style={{ 
            color: isRiskLevel ? color : 'inherit', 
            fontSize: '42px',
            fontWeight: '800',
            margin: '0',
            lineHeight: '1.2',
            background: isRiskLevel ? 'none' : `linear-gradient(135deg, ${color} 0%, ${color}dd 100%)`,
            WebkitBackgroundClip: isRiskLevel ? 'unset' : 'text',
            WebkitTextFillColor: isRiskLevel ? color : 'transparent',
            backgroundClip: isRiskLevel ? 'unset' : 'text',
            textShadow: isRiskLevel ? `0 2px 4px rgba(0,0,0,0.1)` : 'none'
          }}>
            {value}
          </p>
          {subtitle && (
            <p style={{ 
              fontSize: '12px', 
              color: '#94a3b8', 
              margin: '12px 0 0 0',
              fontWeight: '500'
            }}>
              {subtitle}
            </p>
          )}
        </div>
      );
    }
    
    // ============================================================================
    // OPERATIONAL DASHBOARD COMPONENT
    // ============================================================================
    // Main component for displaying operational metrics and seismic activity
    // Features:
    // - Date/time range selection for data filtering
    // - Metric checkboxes for customizable chart views
    // - Real-time data loading from Flask API
    // - Interactive time-series charts with zoom/pan
    // - KPI cards showing summary statistics
    // ============================================================================
    function OperationalDashboard() {
      // State management for date/time range selection - default to last 30 days
      const getDefaultDates = () => {
        const today = new Date();
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(today.getDate() - 30);
        return {
          start: thirtyDaysAgo.toISOString().split('T')[0],
          end: today.toISOString().split('T')[0]
        };
      };
      const defaultDates = getDefaultDates();
      const [startDate, setStartDate] = useState(defaultDates.start);
      const [startTime, setStartTime] = useState('00:00');
      const [endDate, setEndDate] = useState(defaultDates.end);
      const [endTime, setEndTime] = useState('23:59');
      
      // API connection status tracking
      const [apiStatus, setApiStatus] = useState('checking');    // 'checking' | 'connected' | 'disconnected'
      const [usingRealData, setUsingRealData] = useState(false); // Whether real CSV data is loaded
      const [loading, setLoading] = useState(false);            // Loading state for async operations
      const [loadingProgress, setLoadingProgress] = useState({ attempt: 0, total: 10, message: 'Initializing...' });
      
      // Metric visibility toggles - controls which metrics appear on chart
      const [visibleMetrics, setVisibleMetrics] = useState({
        injFlow: true,        // Total injection flow rate [m¬≥/h]
        basinFlow: false,     // Basin injection flow rate [m¬≥/h]
        injWhp: true,         // Injection Wellhead Pressure [bar]
        injAp: false,         // Injection Annular Pressure [bar]
        prodWhp: false,       // Production Wellhead Pressure [bar]
        gt03Whp: false,       // GT03 Wellhead Pressure [bar]
        injTemp: false,       // Injection Wellhead Temperature [¬∞C]
        prodTemp: false,      // Production Wellhead Temperature [¬∞C]
        magnitude: true,      // Seismic magnitude (scatter plot)
        phases: false,       // Show operational phases
        ptls: false,         // Show PTLS probability lines (yellow/orange/red)
        injEnergy: false,    // Injected Energy [MWh]
        extractedEnergy: false, // Extracted Energy [MWh]
        heatExchPower: false,   // Heat Exchanger Thermal Power [kW]
        heatExchEnergy: false   // Heat Exchanger Energy [MWh]
      });
      const [kpiData, setKpiData] = useState({
        totalEvents: 0,
        maxMagnitude: 0,
        avgFlow: 0,
        avgPressure: 0
      });
      const chartRef = useRef(null);
      const chartInstanceRef = useRef(null);
      
      // ============================================================================
      // API HEALTH CHECK
      // ============================================================================
      // Runs once on component mount to verify Flask API is running
      // Checks if LSTM model is loaded and ready for predictions
      // ============================================================================
      useEffect(() => {
        setLoadingProgress({ attempt: 0, total: 10, message: 'Waking up API...' });
        // Faster retries: 1s initial delay instead of 3s (3x faster initial attempts)
        api.healthCheck(10, 1000, (attempt, total, delay) => {
          setLoadingProgress({ 
            attempt, 
            total, 
            message: attempt === 1 ? 'Waking up API...' : `Retrying... (${attempt}/${total})` 
          });
        }).then(result => {
          if (result.status === 'healthy' && result.lstm_loaded) {
            setApiStatus('connected');
            setLoadingProgress({ attempt: 10, total: 10, message: 'Connected!' });
            console.log('‚úÖ API Connected - LSTM loaded:', result.lstm_loaded, 'CatBoost loaded:', result.catboost_loaded);
          } else {
            setApiStatus('disconnected');
            setLoadingProgress({ attempt: 0, total: 10, message: 'API not available' });
            console.log('‚ö†Ô∏è API not available - Please start the API server');
          }
        }).catch(() => {
          setApiStatus('disconnected');
          setLoadingProgress({ attempt: 0, total: 10, message: 'API not available' });
          console.log('‚ö†Ô∏è API not available - Please start the API server');
        });
      }, []); // Empty dependency array = run only once on mount
      
      // ============================================================================
      // DATA LOADING EFFECT
      // ============================================================================
      // Fetches operational and seismic data from API when:
      // - Date/time range changes
      // - API connection status changes
      // Processes data and updates chart with real CSV data
      // ============================================================================
      useEffect(() => {
        const loadData = async () => {
          // Initialize empty chart if API is not connected
          if (apiStatus !== 'connected') {
            console.log('‚è∏Ô∏è API not connected - No data will be displayed');
            setUsingRealData(false);
            setLoading(false);
            
            // Create empty chart to show "API Not Connected" message
            setTimeout(() => {
              const ctx = document.getElementById('operationalChart');
              if (ctx) {
                if (chartInstanceRef.current) {
                  chartInstanceRef.current.destroy();
                }
                chartInstanceRef.current = new Chart(ctx, {
                  type: 'line',
                  data: {
                    labels: ['API', 'Not', 'Connected'],
                    datasets: [{
                      label: 'No Data',
                      data: [0, 0, 0],
                      borderColor: 'rgba(239, 68, 68, 0.3)',
                      backgroundColor: 'rgba(239, 68, 68, 0.1)',
                      borderWidth: 2,
                      pointRadius: 0
                    }]
                  },
                  options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                      legend: { display: false },
                      title: {
                        display: true,
                        text: '‚ö†Ô∏è API Not Connected - Please start the API server (cd api && python app.py)',
                        font: { size: 16, weight: 'bold' },
                        color: '#ef4444',
                        padding: 20
                      },
                      tooltip: { enabled: false }
                    },
                    scales: {
                      x: { 
                        display: true,
                        title: {
                          display: true,
                          text: 'Start API server to load data',
                          color: '#ef4444',
                          font: { size: 12, weight: 'bold' }
                        }
                      },
                      y: { 
                        display: true,
                        title: {
                          display: true,
                          text: 'No data available',
                          color: '#ef4444',
                          font: { size: 12, weight: 'bold' }
                        }
                      }
                    }
                  }
                });
              }
            }, 100);
            return;
          }
          
          setLoading(true);
          try {
            console.log('üìä Loading operational data from API...');
            // Combine date and time for API call
            const startDateTime = `${startDate}T${startTime}:00`;
            const endDateTime = `${endDate}T${endTime}:59`;
            const operationalData = await api.getOperationalData(startDateTime, endDateTime, 500);
            const seismicData = await api.getSeismicData(startDateTime, endDateTime) || [];
            
            if (operationalData && Array.isArray(operationalData) && operationalData.length > 0) {
              setUsingRealData(true);
              console.log(`‚úÖ Loaded ${operationalData.length} operational records and ${seismicData.length} seismic events`);
              
              // Debug: Log sample data
              console.log('üìä Sample operational data:', operationalData.slice(0, 3));
              console.log('üìä Date range requested:', startDateTime, 'to', endDateTime);
              
              // Calculate KPIs - include all values, not just > 0
              const flows = operationalData.map(d => d.inj_flow).filter(v => v !== null && v !== undefined && !isNaN(v));
              const pressures = operationalData.map(d => d.inj_whp).filter(v => v !== null && v !== undefined && !isNaN(v));
              const magnitudes = seismicData.map(d => d.magnitude).filter(v => v !== null && v !== undefined && !isNaN(v) && v !== 0);
              
              console.log('üìä Flow values sample:', flows.slice(0, 5));
              console.log('üìä Pressure values sample:', pressures.slice(0, 5));
              
              // Calculate averages including all valid values (even if some are 0)
              const avgFlow = flows.length > 0 ? (flows.reduce((a, b) => a + b, 0) / flows.length).toFixed(2) : '0.0';
              const avgPressure = pressures.length > 0 ? (pressures.reduce((a, b) => a + b, 0) / pressures.length).toFixed(2) : '0.0';
              
              // For max magnitude, only use non-zero values
              const maxMag = magnitudes.length > 0 ? Math.max(...magnitudes).toFixed(2) : '0.0';
              
              setKpiData({
                totalEvents: seismicData.length,
                maxMagnitude: maxMag,
                avgFlow: avgFlow,
                avgPressure: avgPressure
              });
              
              // Prepare chart data - use full timestamp for proper date handling
              const dates = operationalData.map(d => {
                const ts = d.timestamp;
                if (!ts) return null;
                try {
                  const date = new Date(ts);
                  return date.toISOString().split('T')[0];
                } catch (e) {
                  console.warn('Invalid timestamp:', ts);
                  return null;
                }
              }).filter(d => d !== null);
              
              const injFlow = operationalData.map(d => parseFloat(d.inj_flow) || 0);
              const injWhp = operationalData.map(d => parseFloat(d.inj_whp) || 0);
              
              console.log('üìä Chart dates range:', dates[0], 'to', dates[dates.length - 1]);
              console.log('üìä Chart data points:', dates.length);
              
              // Match seismic events to dates
              const magnitudeByDate = {};
              seismicData.forEach(event => {
                const date = new Date(event.timestamp).toISOString().split('T')[0];
                if (!magnitudeByDate[date] || event.magnitude > magnitudeByDate[date]) {
                  magnitudeByDate[date] = event.magnitude;
                }
              });
              const magnitude = dates.map(date => magnitudeByDate[date] || 0);
              
              // Update chart
              const ctx = document.getElementById('operationalChart');
              if (ctx) {
                // Destroy existing chart first
                if (chartInstanceRef.current) {
                  chartInstanceRef.current.destroy();
                  chartInstanceRef.current = null;
                }
                
                // Sample data for performance (every Nth point)
                const sampleRate = Math.max(1, Math.floor(dates.length / 100));
                const sampledDates = dates.filter((_, i) => i % sampleRate === 0);
                const sampledFlow = injFlow.filter((_, i) => i % sampleRate === 0);
                const sampledPressure = injWhp.filter((_, i) => i % sampleRate === 0);
                const sampledMagnitude = magnitude.filter((_, i) => i % sampleRate === 0);
                
                // Build datasets based on visible metrics
                const datasets = [];
                if (visibleMetrics.injFlow) {
                  datasets.push({
                    label: 'Injection Flow [m¬≥/h]',
                    data: sampledFlow,
                    borderColor: 'rgb(59, 130, 246)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    yAxisID: 'y'
                  });
                }
                if (visibleMetrics.injWhp) {
                  datasets.push({
                    label: 'Injection Pressure [bar]',
                    data: sampledPressure,
                    borderColor: 'rgb(16, 185, 129)',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    yAxisID: 'y'
                  });
                }
                if (visibleMetrics.magnitude) {
                  // Create scatter plot data - only show non-zero magnitudes
                  const magnitudePoints = sampledMagnitude
                    .map((val, idx) => val !== 0 ? {x: idx, y: val} : null)
                    .filter(p => p !== null);
                  
                  datasets.push({
                    label: 'Luckett Magnitude',
                    data: magnitudePoints.length > 0 ? magnitudePoints : sampledMagnitude.map((val, idx) => ({x: idx, y: val})),
                    borderColor: 'rgb(168, 85, 247)',
                    backgroundColor: 'rgba(168, 85, 247, 0.8)',
                    borderWidth: 0,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    showLine: false,
                    yAxisID: 'y1'
                  });
                }
                
                // Add PTLS probability lines if enabled
                if (visibleMetrics.ptls) {
                  const ptlsYellow = sampledDates.map(() => 0);
                  const ptlsOrange = sampledDates.map(() => 0);
                  const ptlsRed = sampledDates.map(() => 0);
                  
                  datasets.push({
                    label: 'p_7d_yellow',
                    data: ptlsYellow,
                    borderColor: 'rgb(251, 191, 36)',
                    backgroundColor: 'rgba(251, 191, 36, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    yAxisID: 'y2'
                  });
                  datasets.push({
                    label: 'p_7d_orange',
                    data: ptlsOrange,
                    borderColor: 'rgb(249, 115, 22)',
                    backgroundColor: 'rgba(249, 115, 22, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    yAxisID: 'y2'
                  });
                  datasets.push({
                    label: 'p_7d_red',
                    data: ptlsRed,
                    borderColor: 'rgb(239, 68, 68)',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    yAxisID: 'y2'
                  });
                }
                
                const chart = new Chart(ctx, {
                  type: 'line',
                  data: {
                    labels: sampledDates,
                    datasets: datasets
                  },
                  options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                      mode: 'index',
                      intersect: false,
                    },
                    plugins: {
                      legend: {
                        display: true,
                        position: 'top',
                      },
                      title: {
                        display: true,
                        text: 'Operational Metrics Over Time (Real Data)'
                      },
                      zoom: {
                        zoom: {
                          wheel: {
                            enabled: true,
                          },
                          pinch: {
                            enabled: true
                          },
                          mode: 'xy',
                        },
                        pan: {
                          enabled: true,
                          mode: 'xy',
                        }
                      }
                    },
                    scales: {
                      x: {
                        display: true,
                        title: {
                          display: true,
                          text: 'Time [UTC]'
                        }
                      },
                      y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                          display: true,
                          text: 'Flow/Pressure'
                        }
                      },
                      y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                          display: true,
                          text: 'Luckett Magnitude'
                        },
                        grid: {
                          drawOnChartArea: false
                        }
                      },
                      y2: {
                        type: 'linear',
                        display: visibleMetrics.ptls,
                        position: 'right',
                        title: {
                          display: true,
                          text: 'PTLS Probability [%]'
                        },
                        min: 0,
                        max: 80,
                        grid: {
                          drawOnChartArea: false
                        }
                      }
                    }
                  }
                });
                
                chartInstanceRef.current = chart;
              } else {
                console.warn('‚ö†Ô∏è Chart canvas not found');
              }
            } else {
              // No data - create empty chart with message
              console.warn('‚ö†Ô∏è No operational data received - creating empty chart');
              const ctx = document.getElementById('operationalChart');
              if (ctx && !chartInstanceRef.current) {
                const chart = new Chart(ctx, {
                  type: 'line',
                  data: {
                    labels: [],
                    datasets: []
                  },
                  options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                      legend: { display: false },
                      title: {
                        display: true,
                        text: 'No data available for selected date range'
                      }
                    }
                  }
                });
                chartInstanceRef.current = chart;
              }
            }
          } catch (error) {
            console.error('‚ùå Real data loading failed:', error.message);
            setUsingRealData(false);
            // Create empty chart on error
            const ctx = document.getElementById('operationalChart');
            if (ctx && !chartInstanceRef.current) {
              const chart = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: [],
                  datasets: []
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: false },
                    title: {
                      display: true,
                      text: 'Error loading data: ' + error.message
                    }
                  }
                }
              });
              chartInstanceRef.current = chart;
            }
          } finally {
            setLoading(false);
          }
        };
        
        loadData();
      }, [startDate, startTime, endDate, endTime, apiStatus]);
      
      // Update chart when visible metrics change (without reloading data)
      useEffect(() => {
        if (!chartInstanceRef.current || !usingRealData || loading) return;
        
        const chart = chartInstanceRef.current;
        if (!chart.data || !chart.data.datasets) return;
        
        // Get all original datasets (we'll store them in a ref or recreate from chart config)
        // For now, just update visibility
        chart.data.datasets.forEach(dataset => {
          if (dataset.label === 'Injection Flow [m¬≥/h]') {
            dataset.hidden = !visibleMetrics.injFlow;
          } else if (dataset.label === 'Injection Pressure [bar]') {
            dataset.hidden = !visibleMetrics.injWhp;
          } else if (dataset.label === 'Luckett Magnitude') {
            dataset.hidden = !visibleMetrics.magnitude;
          } else if (dataset.label === 'p_2d_yellow' || dataset.label === 'p_2d_orange' || dataset.label === 'p_2d_red') {
            dataset.hidden = !visibleMetrics.ptls;
          }
        });
        
        chart.update();
      }, [visibleMetrics, usingRealData, loading]);
      
      // Initialize chart on mount (even if API is disconnected)
      useEffect(() => {
        // Small delay to ensure DOM is ready
        const timer = setTimeout(() => {
          const ctx = document.getElementById('operationalChart');
          if (ctx && !chartInstanceRef.current) {
            // Only create empty chart if API is not connected and no chart exists
            if (apiStatus === 'disconnected') {
              chartInstanceRef.current = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: ['Start', 'API', 'Server'],
                  datasets: [{
                    label: 'No Data',
                    data: [0, 0, 0],
                    borderColor: 'rgba(239, 68, 68, 0.3)',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: true
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: false },
                    title: {
                      display: true,
                      text: '‚ö†Ô∏è API Not Connected - Please start the API server',
                      font: { size: 18, weight: 'bold' },
                      color: '#ef4444',
                      padding: { top: 20, bottom: 20 }
                    },
                    tooltip: { enabled: false }
                  },
                  scales: {
                    x: { 
                      display: true,
                      title: {
                        display: true,
                        text: 'Run: cd api && python app.py',
                        color: '#ef4444',
                        font: { size: 14, weight: 'bold' }
                      },
                      grid: { display: false }
                    },
                    y: { 
                      display: true,
                      title: {
                        display: true,
                        text: 'No data available',
                        color: '#ef4444',
                        font: { size: 14, weight: 'bold' }
                      },
                      grid: { display: false }
                    }
                  }
                }
              });
            }
          }
        }, 200);
        
        return () => {
          clearTimeout(timer);
          if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
            chartInstanceRef.current = null;
          }
        };
      }, [apiStatus]);
      
      return (
        <div>
          <h2>Operational & Seismic Activity</h2>
          
          {apiStatus === 'connected' && usingRealData && (
            <div className="status-banner" style={{ 
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              flexWrap: 'wrap',
              gap: '15px'
            }}>
              <div>
                <div style={{ fontSize: '14px', opacity: 0.95, marginBottom: '6px', fontWeight: '600', letterSpacing: '0.5px' }}>
                  üìä Real Data Connected
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', lineHeight: '1.3' }}>
                  Loading operational metrics from CSV files
                </div>
              </div>
              {loading && (
                <div style={{ 
                  background: 'rgba(255,255,255,0.25)', 
                  backdropFilter: 'blur(10px)',
                  padding: '10px 20px', 
                  borderRadius: '12px',
                  fontSize: '13px',
                  fontWeight: '700',
                  letterSpacing: '0.5px',
                  border: '1px solid rgba(255,255,255,0.3)',
                  boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
                }}>
                  ‚è≥ Loading...
                </div>
              )}
            </div>
          )}
          
          {apiStatus === 'disconnected' && (
            <div className="status-banner" style={{ 
              background: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              flexWrap: 'wrap',
              gap: '15px',
              marginBottom: '25px'
            }}>
              <div>
                <div style={{ fontSize: '14px', opacity: 0.95, marginBottom: '6px', fontWeight: '600', letterSpacing: '0.5px' }}>
                  ‚ö†Ô∏è API Not Connected
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', lineHeight: '1.3', marginBottom: '8px' }}>
                  Please start the API server to view real data
                </div>
                <div style={{ 
                  fontSize: '13px',
                  fontFamily: 'monospace',
                  background: 'rgba(255,255,255,0.2)',
                  padding: '8px 16px',
                  borderRadius: '8px',
                  display: 'inline-block',
                  marginTop: '8px'
                }}>
                  Run: <code style={{ background: 'rgba(0,0,0,0.2)', padding: '4px 8px', borderRadius: '4px', fontWeight: '700' }}>cd api && python app.py</code>
                </div>
              </div>
              <div style={{ 
                background: 'rgba(255,255,255,0.25)', 
                backdropFilter: 'blur(10px)',
                padding: '10px 20px', 
                borderRadius: '12px',
                fontSize: '13px',
                fontWeight: '700',
                letterSpacing: '0.5px',
                border: '1px solid rgba(255,255,255,0.3)',
                boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
              }}>
                üîå Connect API
              </div>
            </div>
          )}
          
          {apiStatus === 'checking' && (
            <div style={{ 
              background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', 
              color: 'white', 
              padding: '20px 25px', 
              borderRadius: '8px', 
              marginBottom: '20px',
              boxShadow: '0 4px 6px rgba(0,0,0,0.1)'
            }}>
              <div style={{ marginBottom: '12px' }}>
                <div style={{ fontSize: '14px', opacity: 0.9, marginBottom: '6px' }}>
                  ‚òï Waking up the API (it's on free tier, needs a coffee break!)
                </div>
                <div style={{ fontSize: '18px', fontWeight: '600', marginBottom: '10px' }}>
                  {loadingProgress.message}
                </div>
                <div style={{ 
                  background: 'rgba(255,255,255,0.2)', 
                  borderRadius: '10px', 
                  height: '8px', 
                  overflow: 'hidden',
                  marginBottom: '8px'
                }}>
                  <div style={{ 
                    background: 'rgba(255,255,255,0.9)', 
                    height: '100%', 
                    width: `${(loadingProgress.attempt / loadingProgress.total) * 100}%`,
                    transition: 'width 0.3s ease',
                    borderRadius: '10px'
                  }}></div>
                </div>
                <div style={{ fontSize: '12px', opacity: 0.8 }}>
                  Attempt {loadingProgress.attempt} of {loadingProgress.total} ‚Ä¢ This may take 30-60 seconds on first load
                </div>
              </div>
            </div>
          )}
          
          <div className="kpis">
            <KPICard 
              title="Seismic Events" 
              value={kpiData.totalEvents.toString()} 
              color="#3b82f6"
              subtitle={usingRealData ? "From CSV data" : "No data"}
            />
            <KPICard 
              title="Max Magnitude" 
              value={kpiData.maxMagnitude} 
              color="#ef4444"
              subtitle={usingRealData ? "Real events" : "No data"}
            />
            <KPICard 
              title="Avg Flow Rate" 
              value={kpiData.avgFlow} 
              color="#10b981"
              subtitle={usingRealData ? "m¬≥/h" : "No data"}
            />
            <KPICard 
              title="Avg Pressure" 
              value={kpiData.avgPressure} 
              color="#f59e0b"
              subtitle={usingRealData ? "bar" : "No data"}
            />
          </div>
          
          <div className="date-selector">
            <div className="date-input">
              <label>Start Date</label>
              <input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
              />
            </div>
            <div className="date-input">
              <label>Start Time</label>
              <input
                type="time"
                value={startTime}
                onChange={(e) => setStartTime(e.target.value)}
              />
            </div>
            <div className="date-input">
              <label>End Date</label>
              <input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
              />
            </div>
            <div className="date-input">
              <label>End Time</label>
              <input
                type="time"
                value={endTime}
                onChange={(e) => setEndTime(e.target.value)}
              />
            </div>
          </div>
          
          <div style={{ 
            background: 'linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%)',
            padding: '20px', 
            borderRadius: '16px', 
            marginBottom: '20px',
            border: '2px solid rgba(102, 126, 234, 0.15)',
            boxShadow: '0 4px 12px rgba(102, 126, 234, 0.08)'
          }}>
            <label style={{ 
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              marginBottom: '15px', 
              fontWeight: '700', 
              fontSize: '16px',
              color: '#1f2937'
            }}>
              ‚öôÔ∏è Select Metrics to Display:
            </label>
            <div style={{ 
              display: 'grid', 
              gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', 
              gap: '12px' 
            }}>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.injFlow}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, injFlow: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Total injection flow rate [m¬≥/h]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.basinFlow}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, basinFlow: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Basin injection flow rate [m¬≥/h]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.injWhp}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, injWhp: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Injection Wellhead Pressure [bar]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.injAp}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, injAp: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Injection Annular Pressure [bar]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.prodWhp}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, prodWhp: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Production Wellhead Pressure [bar]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.gt03Whp}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, gt03Whp: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>GT03 Wellhead Pressure [bar]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.injTemp}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, injTemp: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Injection Wellhead Temperature [¬∞C]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.prodTemp}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, prodTemp: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Production Wellhead Temperature [¬∞C]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.magnitude}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, magnitude: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Show seismicity</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.phases}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, phases: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Show phases</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.ptls}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, ptls: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Show ptls</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.injEnergy}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, injEnergy: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Injected Energy [MWh]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.extractedEnergy}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, extractedEnergy: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Extracted Energy [MWh]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.heatExchPower}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, heatExchPower: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Heat Exchanger Thermal Power [kW]</span>
              </label>
              <label style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={visibleMetrics.heatExchEnergy}
                  onChange={(e) => setVisibleMetrics({...visibleMetrics, heatExchEnergy: e.target.checked})}
                  style={{ marginRight: '8px', width: '18px', height: '18px', cursor: 'pointer' }}
                />
                <span>Heat Exchanger Energy [MWh]</span>
              </label>
            </div>
          </div>
          
            <div className="chart-container">
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px', flexWrap: 'wrap', gap: '10px' }}>
              <h3>Operational Metrics Over Time</h3>
              <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                {usingRealData && (
                  <span style={{ 
                    background: '#10b981', 
                    color: 'white', 
                    padding: '4px 12px', 
                    borderRadius: '4px', 
                    fontSize: '12px',
                    fontWeight: '600'
                  }}>
                    üìä Real Data
                  </span>
                )}
                {loading && (
                  <span style={{ 
                    background: '#3b82f6', 
                    color: 'white', 
                    padding: '4px 12px', 
                    borderRadius: '4px', 
                    fontSize: '12px',
                    fontWeight: '600'
                  }}>
                    Loading...
                  </span>
                )}
                <button
                  onClick={() => {
                    if (chartInstanceRef.current) {
                      const url = chartInstanceRef.current.toBase64Image();
                      const link = document.createElement('a');
                      link.download = `chart-${new Date().toISOString().split('T')[0]}.png`;
                      link.href = url;
                      link.click();
                    }
                  }}
                  style={{
                    background: '#4c51bf',
                    color: 'white',
                    border: 'none',
                    padding: '6px 12px',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: '600'
                  }}
                  title="Screenshot"
                >
                  üì∑
                </button>
                <button
                  onClick={() => {
                    if (chartInstanceRef.current) {
                      chartInstanceRef.current.zoom(1.2);
                    }
                  }}
                  style={{
                    background: '#4c51bf',
                    color: 'white',
                    border: 'none',
                    padding: '6px 12px',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: '600'
                  }}
                  title="Zoom In"
                >
                  üîç+
                </button>
                <button
                  onClick={() => {
                    if (chartInstanceRef.current) {
                      chartInstanceRef.current.zoom(0.8);
                    }
                  }}
                  style={{
                    background: '#4c51bf',
                    color: 'white',
                    border: 'none',
                    padding: '6px 12px',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: '600'
                  }}
                  title="Zoom Out"
                >
                  üîç-
                </button>
                <button
                  onClick={() => {
                    if (chartInstanceRef.current && chartInstanceRef.current.resetZoom) {
                      chartInstanceRef.current.resetZoom();
                    }
                  }}
                  style={{
                    background: '#4c51bf',
                    color: 'white',
                    border: 'none',
                    padding: '6px 12px',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    fontSize: '12px',
                    fontWeight: '600'
                  }}
                  title="Reset Zoom"
                >
                  ‚Üª
                </button>
              </div>
            </div>
            <canvas id="operationalChart"></canvas>
            {!usingRealData && apiStatus === 'disconnected' && (
              <div style={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                textAlign: 'center',
                color: '#718096',
                zIndex: 10
              }}>
                <div style={{ fontSize: '24px', marginBottom: '10px' }}>üìä</div>
                <div style={{ fontSize: '16px', fontWeight: '600', marginBottom: '5px' }}>
                  No Chart Data Available
                </div>
                <div style={{ fontSize: '12px' }}>
                  Start the API server to view data
                </div>
              </div>
            )}
            <div style={{ 
              marginTop: '10px', 
              fontSize: '11px', 
              color: '#718096', 
              fontStyle: 'italic',
              textAlign: 'center'
            }}>
              The graph shows 'cleaned up' operational metrics (e.g. flow set to zero when no production).
            </div>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // RISK DASHBOARD COMPONENT
    // ============================================================================
    // Displays Ensemble model predictions for 2-day seismic risk forecast
    // Features:
    // - Current risk level indicator (Green/Yellow/Orange/Red)
    // - 2-day probability forecast chart
    // - Alert probability cards (Yellow/Orange/Red)
    // - Day-by-day risk status for next 2 days
    // Uses real operational data to generate predictions via LSTM model
    // ============================================================================
    function RiskDashboard() {
      const chartRef = useRef(null);
      const [chartInstance, setChartInstance] = useState(null);
      const [apiStatus, setApiStatus] = useState('checking');
      const [loading, setLoading] = useState(false);
      const [usingRealData, setUsingRealData] = useState(false);
      const [forecastData, setForecastData] = useState(null);
      const [currentRisk, setCurrentRisk] = useState('MEDIUM');
      const [riskProbabilities, setRiskProbabilities] = useState({ yellow: 0, orange: 0, red: 0 });
      const [testData, setTestData] = useState(null);
      const [showTestData, setShowTestData] = useState(false);
      const [loadingProgress, setLoadingProgress] = useState({ attempt: 0, total: 10, message: 'Initializing...' });
      
      // Check API and load forecast data
      useEffect(() => {
        const loadForecast = async () => {
          try {
            // Start health check with faster retries (1s instead of 3s)
            setLoadingProgress({ attempt: 0, total: 10, message: 'Waking up API...' });
            const healthPromise = api.healthCheck(10, 1000, (attempt, total, delay) => {
              setLoadingProgress({ 
                attempt, 
                total, 
                message: attempt === 1 ? 'Waking up API...' : `Retrying... (${attempt}/${total})` 
              });
            });
            
            // OPTIMIZATION: Start data loading in parallel (optimistic loading)
            // This saves time by starting the request while API is waking up
            let dataPromise = null;
            try {
              const dataController = new AbortController();
              const dataTimeout = setTimeout(() => dataController.abort(), 30000);
              dataPromise = fetch(`${api.baseURL}/data/latest`, {
                signal: dataController.signal,
                cache: 'no-cache'
              }).then(response => {
                clearTimeout(dataTimeout);
                return response;
              }).catch(error => {
                clearTimeout(dataTimeout);
                throw error;
              });
            } catch (e) {
              // Ignore if fetch setup fails, we'll retry after health check
              console.log('‚ö†Ô∏è Parallel data fetch setup failed, will retry:', e.message);
            }
            
            // Wait for health check
            const health = await healthPromise;
            
            if (health.status !== 'healthy' || !health.lstm_loaded) {
              setApiStatus('disconnected');
              setLoadingProgress({ attempt: 0, total: 10, message: 'API not available' });
              console.log('‚ö†Ô∏è API not available - Please start the API server');
              console.log('Health check response:', health);
              return;
            }
            
            setApiStatus('connected');
            setLoading(true);
            
            // Load REAL data from API (use parallel request if available, otherwise fetch)
            const now = new Date();
            let dataToUse;
            let isRealData = false;
            
            try {
              console.log('üìä Loading real data from API...');
              setLoadingProgress({ attempt: 10, total: 10, message: 'Loading data...' });
              
              // Use parallel request if available, otherwise fetch fresh
              let response;
              if (dataPromise) {
                try {
                  response = await dataPromise;
                  console.log('‚úÖ Used parallel data request');
                } catch (e) {
                  // Parallel request failed, fetch fresh
                  console.log('‚ö†Ô∏è Parallel request failed, fetching fresh:', e.message);
                  const controller = new AbortController();
                  const timeoutId = setTimeout(() => controller.abort(), 30000);
                  response = await fetch(`${api.baseURL}/data/latest`, {
                    signal: controller.signal,
                    cache: 'no-cache'
                  });
                  clearTimeout(timeoutId);
                }
              } else {
                // No parallel request, fetch fresh
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                response = await fetch(`${api.baseURL}/data/latest`, {
                  signal: controller.signal,
                  cache: 'no-cache'
                });
                clearTimeout(timeoutId);
              }
              
              if (response.ok) {
                const result = await response.json();
                if (result.data && result.data.length > 0) {
                  const recordCount = result.records_loaded || result.data.length;
                  console.log(`‚úÖ Loaded ${recordCount} records (${result.source || 'sample'} data)!`);
                  setUsingRealData(true);
                  isRealData = true;
                  // Use available data (at least 1 record, up to 24)
                  const dataToUseCount = Math.min(result.data.length, 24);
                  dataToUse = result.data.slice(-dataToUseCount);
                  // If we have less than 24, pad with the last record
                  while (dataToUse.length < 24 && dataToUse.length > 0) {
                    dataToUse.unshift({...dataToUse[0]});
                  }
                  // Store test data for display
                  setTestData(dataToUse);
                } else {
                  throw new Error('No data available');
                }
              } else {
                throw new Error('API returned error');
              }
            } catch (error) {
              console.error('‚ùå Real data loading failed:', error.message);
              setUsingRealData(false);
              isRealData = false;
              // No sample data - throw error to prevent forecast
              throw new Error('Cannot generate forecast without real data. Please ensure API is running and CSV files are available.');
            }
            
            // Get 2-day forecast from API using real data
            console.log('üì° Requesting forecast from API with', dataToUse.length, 'hours of data');
            setLoadingProgress({ attempt: loadingProgress.attempt, total: loadingProgress.total, message: 'Generating forecast...' });
            const forecast = await api.getForecast(now.toISOString(), dataToUse);
            console.log('üìä Received forecast response:', forecast);
            
            if (!forecast || forecast.length === 0) {
              throw new Error('No forecast data received from API');
            }
            
            // Format forecast data for chart
            const dates = forecast.map(f => {
              try {
                const date = new Date(f.date);
                if (isNaN(date.getTime())) {
                  // If date is invalid, use index-based date
                  const baseDate = new Date(now);
                  baseDate.setDate(baseDate.getDate() + forecast.indexOf(f));
                  return baseDate.toISOString().split('T')[0];
                }
                return date.toISOString().split('T')[0];
              } catch (e) {
                const baseDate = new Date(now);
                baseDate.setDate(baseDate.getDate() + forecast.indexOf(f));
                return baseDate.toISOString().split('T')[0];
              }
            });
            const yellow = forecast.map(f => {
              const probs = f.probabilities || {};
              const val = (probs.yellow || probs.p_yellow || 0) * 100;
              return Math.max(0, Math.min(100, val)); // Ensure 0-100 range
            });
            const orange = forecast.map(f => {
              const probs = f.probabilities || {};
              const val = (probs.orange || probs.p_orange || 0) * 100;
              return Math.max(0, Math.min(100, val));
            });
            const red = forecast.map(f => {
              const probs = f.probabilities || {};
              const val = (probs.red || probs.p_red || 0) * 100;
              return Math.max(0, Math.min(100, val));
            });
            
            console.log('üìä Chart data prepared:', {
              dates: dates,
              yellow: yellow,
              orange: orange,
              red: red,
              forecastLength: forecast.length
            });
            
            console.log('üìà Chart data - Yellow:', yellow.slice(0, 3), 'Orange:', orange.slice(0, 3), 'Red:', red.slice(0, 3));
            console.log('üìä Full forecast probabilities:', forecast.map(f => ({
              date: f.date,
              probs: f.probabilities,
              risk: f.risk_level
            })));
            
            // Update KPIs with today's prediction (first forecast day)
            if (forecast && forecast.length > 0) {
              const today = forecast[0];
              console.log('üìä Forecast data:', today);
              
              if (today.probabilities) {
                const yellowPct = ((today.probabilities.yellow || 0) * 100).toFixed(1);
                const orangePct = ((today.probabilities.orange || 0) * 100).toFixed(1);
                const redPct = ((today.probabilities.red || 0) * 100).toFixed(1);
                
                const probs = {
                  yellow: parseFloat(yellowPct),
                  orange: parseFloat(orangePct),
                  red: parseFloat(redPct)
                };
                
                setRiskProbabilities(probs);
                console.log('‚úÖ Updated probabilities:', probs);
                console.log('üìä Today probabilities object:', today.probabilities);
              } else {
                console.warn('‚ö†Ô∏è No probabilities in forecast data:', today);
              }
              
              // Determine current risk level
              if (today.risk_level_code !== undefined) {
                if (today.risk_level_code === 0) {
                  setCurrentRisk('LOW');
                } else if (today.risk_level_code === 1) {
                  setCurrentRisk('YELLOW');
                } else if (today.risk_level_code === 2) {
                  setCurrentRisk('ORANGE');
                } else {
                  setCurrentRisk('HIGH');
                }
                console.log('‚úÖ Updated risk level:', today.risk_level_code, '‚Üí', today.risk_level);
              } else if (today.risk_level) {
                // Fallback: use risk_level string
                const level = today.risk_level.toUpperCase();
                if (level === 'GREEN') setCurrentRisk('LOW');
                else if (level === 'YELLOW') setCurrentRisk('YELLOW');
                else if (level === 'ORANGE') setCurrentRisk('ORANGE');
                else if (level === 'RED') setCurrentRisk('HIGH');
              }
            } else {
              console.warn('‚ö†Ô∏è No forecast data received');
            }
            
            setForecastData(forecast);
            setLoading(false);
            
            // Update chart with API data
            const ctx = document.getElementById('riskChart');
            if (ctx) {
              if (chartInstance) {
                chartInstance.destroy();
              }
              
              const chart = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: dates,
                  datasets: [
                    {
                      label: 'p_2d_yellow',
                      data: yellow,
                      borderColor: 'rgb(251, 191, 36)',
                      backgroundColor: 'rgba(251, 191, 36, 0.1)',
                      borderWidth: 3,
                      tension: 0.3,
                      fill: true
                    },
                    {
                      label: 'p_2d_orange',
                      data: orange,
                      borderColor: 'rgb(249, 115, 22)',
                      backgroundColor: 'rgba(249, 115, 22, 0.1)',
                      borderWidth: 3,
                      tension: 0.3,
                      fill: true
                    },
                    {
                      label: 'p_2d_red',
                      data: red,
                      borderColor: 'rgb(239, 68, 68)',
                      backgroundColor: 'rgba(239, 68, 68, 0.1)',
                      borderWidth: 3,
                      tension: 0.3,
                      fill: true
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'top' },
                    title: { 
                      display: true, 
                      text: isRealData ? '2-Day Seismic Risk Forecast - Ensemble Model Predictions (Real Data)' : '2-Day Seismic Risk Forecast - Ensemble Model Predictions (API Required)',
                      font: { size: 16, weight: 'bold' }
                    },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                        },
                        footer: function(tooltipItems) {
                          const dataIndex = tooltipItems[0].dataIndex;
                          if (forecastData && forecastData[dataIndex]) {
                            const day = forecastData[dataIndex];
                            const maxProb = Math.max(
                              day.probabilities.yellow,
                              day.probabilities.orange,
                              day.probabilities.red
                            );
                            return `Predicted Risk: ${day.risk_level} (${(maxProb * 100).toFixed(1)}% confidence)`;
                          }
                          return '';
                        }
                      }
                    }
                  },
                  scales: {
                    x: { 
                      display: true, 
                      title: { display: true, text: 'Date (Next 2 Days)', font: { size: 12, weight: 'bold' } },
                      grid: { color: 'rgba(0,0,0,0.05)' }
                    },
                    y: { 
                      display: true, 
                      title: { display: true, text: 'Prediction Probability (%)', font: { size: 12, weight: 'bold' } }, 
                      min: 0, 
                      max: 100,
                      grid: { color: 'rgba(0,0,0,0.05)' },
                      ticks: {
                        callback: function(value) {
                          return value + '%';
                        }
                      }
                    }
                  }
                }
              });
              
              setChartInstance(chart);
            }
          } catch (error) {
            console.error('Failed to load forecast from API:', error);
            setApiStatus('disconnected');
            setLoading(false);
            // No mock data - only real data
          }
        };
        
        loadForecast();
      }, []);
      
      
      return (
        <div>
          <h2>Seismic Risk & Prediction</h2>
          
          <div className="kpis">
            <KPICard 
              title="Current Risk (LSTM)" 
              value={currentRisk} 
              color={
                currentRisk === 'LOW' ? '#10b981' :
                currentRisk === 'YELLOW' ? '#fbbf24' :
                currentRisk === 'ORANGE' ? '#f97316' : '#ef4444'
              } 
            />
            <KPICard 
              title="Yellow Alert (2d)" 
              value={`${riskProbabilities.yellow.toFixed(1)}%`} 
              color="#fbbf24" 
            />
            <KPICard 
              title="Orange Alert (2d)" 
              value={`${riskProbabilities.orange.toFixed(1)}%`} 
              color="#f97316" 
            />
            <KPICard 
              title="Red Alert (2d)" 
              value={`${riskProbabilities.red.toFixed(1)}%`} 
              color="#ef4444" 
            />
          </div>
          
          {apiStatus === 'connected' && (
            <div style={{ 
              background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', 
              color: 'white', 
              padding: '20px 30px', 
              borderRadius: '16px', 
              marginBottom: '25px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              boxShadow: '0 8px 24px rgba(102, 126, 234, 0.3)',
              flexWrap: 'wrap',
              gap: '15px'
            }}>
              <div>
                <div style={{ fontSize: '14px', opacity: 0.95, marginBottom: '6px', fontWeight: '600', letterSpacing: '0.5px' }}>
                  ü§ñ Ensemble Model Active (LSTM + CatBoost)
                </div>
                <div style={{ fontSize: '20px', fontWeight: '700', lineHeight: '1.3' }}>
                  {usingRealData ? '‚úì Using Real Operational Data' : '‚ö† API Not Connected - Start API Server'} ‚Üí Predicting 2-Day Seismic Risk
                </div>
              </div>
              <div style={{ 
                background: 'rgba(255,255,255,0.25)', 
                backdropFilter: 'blur(10px)',
                padding: '10px 20px', 
                borderRadius: '12px',
                fontSize: '13px',
                fontWeight: '700',
                letterSpacing: '0.5px',
                border: '1px solid rgba(255,255,255,0.3)',
                boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
              }}>
                Model: lstm_model_ammad.h5 + CatBoost
              </div>
            </div>
          )}
          
          {/* Test Data Display Section */}
          {testData && testData.length > 0 && (
            <div style={{ marginBottom: '20px' }}>
              <button
                onClick={() => setShowTestData(!showTestData)}
                style={{
                  background: showTestData ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : '#e5e7eb',
                  color: showTestData ? 'white' : '#374151',
                  border: 'none',
                  padding: '12px 24px',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  fontSize: '14px',
                  fontWeight: '600',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                  transition: 'all 0.3s ease'
                }}
              >
                {showTestData ? '‚ñº' : '‚ñ∂'} {showTestData ? 'Hide' : 'Show'} Test Data ({testData.length} records)
              </button>
              
              {showTestData && (
                <div style={{
                  marginTop: '15px',
                  background: 'white',
                  borderRadius: '12px',
                  padding: '20px',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                  maxHeight: '500px',
                  overflowY: 'auto'
                }}>
                  <h3 style={{ marginTop: 0, marginBottom: '15px', color: '#1f2937' }}>
                    üìä Test Data Used for Prediction (Last {testData.length} hours)
                  </h3>
                  <div style={{ overflowX: 'auto' }}>
                    <table style={{ 
                      width: '100%', 
                      borderCollapse: 'collapse',
                      fontSize: '12px'
                    }}>
                      <thead>
                        <tr style={{ 
                          background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                          color: 'white'
                        }}>
                          <th style={{ padding: '10px', textAlign: 'left', border: '1px solid #ddd' }}>#</th>
                          <th style={{ padding: '10px', textAlign: 'left', border: '1px solid #ddd' }}>Timestamp</th>
                          <th style={{ padding: '10px', textAlign: 'right', border: '1px solid #ddd' }}>Inj Flow</th>
                          <th style={{ padding: '10px', textAlign: 'right', border: '1px solid #ddd' }}>Inj Pressure</th>
                          <th style={{ padding: '10px', textAlign: 'right', border: '1px solid #ddd' }}>Inj Temp</th>
                          <th style={{ padding: '10px', textAlign: 'right', border: '1px solid #ddd' }}>Prod Temp</th>
                          <th style={{ padding: '10px', textAlign: 'right', border: '1px solid #ddd' }}>Event Count</th>
                          <th style={{ padding: '10px', textAlign: 'right', border: '1px solid #ddd' }}>Max Mag</th>
                        </tr>
                      </thead>
                      <tbody>
                        {testData.slice(-10).map((record, idx) => (
                          <tr key={idx} style={{ 
                            background: idx % 2 === 0 ? '#f9fafb' : 'white',
                            borderBottom: '1px solid #e5e7eb'
                          }}>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb' }}>{testData.length - 10 + idx + 1}</td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', fontFamily: 'monospace', fontSize: '11px' }}>
                              {record.timestamp ? new Date(record.timestamp).toLocaleString() : 'N/A'}
                            </td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', textAlign: 'right' }}>
                              {parseFloat(record.inj_flow || 0).toFixed(2)} m¬≥/h
                            </td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', textAlign: 'right' }}>
                              {parseFloat(record.inj_whp || 0).toFixed(2)} bar
                            </td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', textAlign: 'right' }}>
                              {parseFloat(record.inj_temp || 0).toFixed(1)} ¬∞C
                            </td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', textAlign: 'right' }}>
                              {parseFloat(record.prod_temp || 0).toFixed(1)} ¬∞C
                            </td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', textAlign: 'right' }}>
                              {record.event_count || 0}
                            </td>
                            <td style={{ padding: '8px', border: '1px solid #e5e7eb', textAlign: 'right' }}>
                              {parseFloat(record.max_magnitude || 0).toFixed(2)}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                    {testData.length > 10 && (
                      <div style={{ 
                        marginTop: '10px', 
                        fontSize: '12px', 
                        color: '#6b7280',
                        fontStyle: 'italic',
                        textAlign: 'center'
                      }}>
                        Showing last 10 of {testData.length} records. Full data available in browser console.
                      </div>
                    )}
                    <div style={{ 
                      marginTop: '15px', 
                      padding: '12px', 
                      background: '#f3f4f6',
                      borderRadius: '8px',
                      fontSize: '12px'
                    }}>
                      <strong>Data Summary:</strong>
                      <ul style={{ margin: '8px 0', paddingLeft: '20px' }}>
                        <li>Total records: {testData.length}</li>
                        <li>Avg Injection Flow: {(
                          testData.reduce((sum, r) => sum + parseFloat(r.inj_flow || 0), 0) / testData.length
                        ).toFixed(2)} m¬≥/h</li>
                        <li>Avg Injection Pressure: {(
                          testData.reduce((sum, r) => sum + parseFloat(r.inj_whp || 0), 0) / testData.length
                        ).toFixed(2)} bar</li>
                        <li>Total Seismic Events: {testData.reduce((sum, r) => sum + (r.event_count || 0), 0)}</li>
                        <li>Max Magnitude: {Math.max(...testData.map(r => parseFloat(r.max_magnitude || 0))).toFixed(2)}</li>
                      </ul>
                    </div>
                  </div>
                </div>
              )}
            </div>
          )}
          
          <div className="risk-dashboard-flex" style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>
            <div className="chart-container" style={{ flex: 2 }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px', flexWrap: 'wrap', gap: '10px' }}>
                <h3>2-Day Probability Forecast</h3>
                {apiStatus === 'connected' && (
                  <span style={{ 
                    background: '#10b981', 
                    color: 'white', 
                    padding: '4px 12px', 
                    borderRadius: '4px', 
                    fontSize: '12px',
                    fontWeight: '600',
                    marginRight: '8px'
                  }}>
                    ‚úì API Connected
                  </span>
                )}
                {usingRealData && (
                  <span style={{ 
                    background: '#3b82f6', 
                    color: 'white', 
                    padding: '4px 12px', 
                    borderRadius: '4px', 
                    fontSize: '12px',
                    fontWeight: '600'
                  }}>
                    üìä Real Data
                  </span>
                )}
                {apiStatus === 'disconnected' && (
                  <span style={{ 
                    background: '#ef4444', 
                    color: 'white', 
                    padding: '4px 12px', 
                    borderRadius: '4px', 
                    fontSize: '12px',
                    fontWeight: '600'
                  }}>
                    ‚ö† API Not Connected
                  </span>
                )}
                {loading && (
                  <span style={{ 
                    background: '#3b82f6', 
                    color: 'white', 
                    padding: '4px 12px', 
                    borderRadius: '4px', 
                    fontSize: '12px',
                    fontWeight: '600'
                  }}>
                    Loading...
                  </span>
                )}
              </div>
              <canvas id="riskChart"></canvas>
            </div>
            
            <div className="chart-container" style={{ flex: 1 }}>
              <h3>Risk Indicator (LSTM Prediction)</h3>
              <div 
                className={`risk-indicator ${
                  currentRisk === 'LOW' ? 'risk-low' :
                  currentRisk === 'YELLOW' ? 'risk-medium' :
                  currentRisk === 'ORANGE' ? 'risk-high' : 'risk-critical'
                }`}
                style={{
                  fontSize: '80px',
                  width: '150px',
                  height: '150px',
                  margin: '20px auto',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  borderRadius: '50%',
                  background: 
                    currentRisk === 'LOW' ? 'linear-gradient(135deg, #10b981, #059669)' :
                    currentRisk === 'YELLOW' ? 'linear-gradient(135deg, #fbbf24, #f59e0b)' :
                    currentRisk === 'ORANGE' ? 'linear-gradient(135deg, #f97316, #ea580c)' :
                    'linear-gradient(135deg, #ef4444, #dc2626)',
                  boxShadow: `0 8px 16px ${
                    currentRisk === 'LOW' ? 'rgba(16, 185, 129, 0.3)' :
                    currentRisk === 'YELLOW' ? 'rgba(251, 191, 36, 0.3)' :
                    currentRisk === 'ORANGE' ? 'rgba(249, 115, 22, 0.3)' :
                    'rgba(239, 68, 68, 0.3)'
                  }`
                }}
              >
                {currentRisk === 'LOW' ? '‚úì' : currentRisk === 'YELLOW' ? '‚ö†' : currentRisk === 'ORANGE' ? '‚ö°' : 'üö®'}
              </div>
              <div style={{ 
                textAlign: 'center', 
                color: currentRisk === 'LOW' ? '#10b981' : currentRisk === 'YELLOW' ? '#f59e0b' : currentRisk === 'ORANGE' ? '#f97316' : '#ef4444', 
                fontWeight: 700,
                fontSize: '20px',
                marginTop: '10px'
              }}>
                {currentRisk} RISK
              </div>
              <div style={{ marginTop: '20px', fontSize: '13px', color: '#64748b', textAlign: 'center', lineHeight: '1.6' }}>
                {currentRisk === 'LOW' && '‚úÖ Normal operations - Continue monitoring'}
                {currentRisk === 'YELLOW' && '‚ö†Ô∏è Elevated risk - Monitor injection rates closely'}
                {currentRisk === 'ORANGE' && '‚ö° High risk - Consider reducing injection rates'}
                {currentRisk === 'HIGH' && 'üö® Critical risk - Immediate action required'}
              </div>
              
              {forecastData && forecastData.length > 0 && (
                <div style={{ 
                  marginTop: '25px', 
                  padding: '15px', 
                  background: '#f8fafc', 
                  borderRadius: '8px',
                  border: '1px solid #e2e8f0'
                }}>
                  <div style={{ fontSize: '12px', color: '#64748b', marginBottom: '10px', fontWeight: '600' }}>
                    NEXT 2 DAYS FORECAST
                  </div>
                  {forecastData.slice(0, 2).map((day, idx) => (
                    <div key={idx} style={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center',
                      padding: '8px 0',
                      borderBottom: idx < 6 ? '1px solid #e2e8f0' : 'none'
                    }}>
                      <div style={{ fontSize: '12px', color: '#475569' }}>
                        Day {idx + 1}: {new Date(day.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                      </div>
                      <div style={{ 
                        fontSize: '11px', 
                        padding: '4px 8px', 
                        borderRadius: '4px',
                        background: day.risk_level_code === 0 ? '#d1fae5' : 
                                   day.risk_level_code === 1 ? '#fef3c7' :
                                   day.risk_level_code === 2 ? '#fed7aa' : '#fee2e2',
                        color: day.risk_level_code === 0 ? '#065f46' :
                               day.risk_level_code === 1 ? '#92400e' :
                               day.risk_level_code === 2 ? '#9a3412' : '#991b1b',
                        fontWeight: '600'
                      }}>
                        {day.risk_level}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }
    
    // Main App Component
    function App() {
      const [activeTab, setActiveTab] = useState('operational');
      
      return (
        <div className="container">
          <header>
            <div>
              <div className="logo">Geothermal Plant Monitoring</div>
              <div className="subtitle">React Dashboard - Operational & Seismic Analysis</div>
            </div>
          </header>
          
          <div className="nav-tabs">
            <button
              className={`nav-tab ${activeTab === 'operational' ? 'active' : ''}`}
              onClick={() => setActiveTab('operational')}
            >
              Operational Dashboard
            </button>
            <button
              className={`nav-tab ${activeTab === 'risk' ? 'active' : ''}`}
              onClick={() => setActiveTab('risk')}
            >
              Risk Dashboard
            </button>
          </div>
          
          {activeTab === 'operational' && <OperationalDashboard />}
          {activeTab === 'risk' && <RiskDashboard />}
          
          <div style={{ textAlign: 'center', color: '#718096', fontSize: '12px', marginTop: '20px' }}>
            React Dashboard powered by Chart.js
          </div>
        </div>
      );
    }
    
    // Render the app with error handling
    window.addEventListener('error', function(e) {
      console.error('Global error:', e.error);
      const rootEl = document.getElementById('root');
      if (rootEl && !rootEl.innerHTML.includes('Error')) {
        rootEl.innerHTML = `
          <div style="padding: 20px; font-family: Arial; background: #fee; border: 2px solid #fcc; margin: 20px;">
            <h2>‚ö†Ô∏è JavaScript Error Detected</h2>
            <p><strong>Error:</strong> ${e.error ? e.error.message : 'Unknown error'}</p>
            <p><strong>File:</strong> ${e.filename || 'Unknown'}</p>
            <p><strong>Line:</strong> ${e.lineno || 'Unknown'}</p>
            <p>Check browser console (F12) for more details.</p>
          </div>
        `;
      }
    });
    
    // Wait for DOM and React to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', renderApp);
    } else {
      renderApp();
    }
    
    function renderApp() {
      try {
        const rootEl = document.getElementById('root');
        if (!rootEl) {
          console.error('Root element not found!');
          return;
        }
        
        // Check if React is loaded
        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
          rootEl.innerHTML = `
            <div style="padding: 20px; font-family: Arial; background: #fee; border: 2px solid #fcc;">
              <h2>‚ö†Ô∏è React Not Loaded</h2>
              <p>React libraries failed to load. Check your internet connection.</p>
              <p>CDN URLs:</p>
              <ul>
                <li>React: https://unpkg.com/react@18/umd/react.production.min.js</li>
                <li>ReactDOM: https://unpkg.com/react-dom@18/umd/react-dom.production.min.js</li>
              </ul>
            </div>
          `;
          return;
        }
        
        // Use React 18 createRoot if available, otherwise fallback to render
        if (ReactDOM.createRoot) {
          const root = ReactDOM.createRoot(rootEl);
          root.render(<App />);
        } else {
          // Fallback for older React versions
          ReactDOM.render(<App />, rootEl);
        }
        
        console.log('‚úÖ Dashboard rendered successfully!');
      } catch (error) {
        console.error('Error rendering app:', error);
        const rootEl = document.getElementById('root');
        if (rootEl) {
          rootEl.innerHTML = `
            <div style="padding: 20px; font-family: Arial; background: #fee; border: 2px solid #fcc;">
              <h2>‚ùå Error Loading Dashboard</h2>
              <p><strong>Error:</strong> ${error.message}</p>
              <p><strong>Stack:</strong></p>
              <pre style="background: #fff; padding: 10px; overflow: auto;">${error.stack || 'No stack trace'}</pre>
              <p><strong>Solution:</strong> Open browser console (F12) and check for errors.</p>
            </div>
          `;
        }
      }
    }
  </script>
</body>
</html>

